---
title: "Lexicalã«ã¤ã„ã¦ã‚„é–‹ç™ºã—ã¦ã„ã‚‹ã“ã¨ã‚’ã¤ã‚‰ã¤ã‚‰ã¨æ›¸ã"
emoji: "ğŸ˜º"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["React", "Lexical"]
published: true
---

## ã¯ã˜ã‚ã«

ç¾åœ¨ç‹¬è‡ªã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ä½œã‚ã†ã¨ã—ã¦ã„ã‚‹ã®ã§ã™ãŒã€ãã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦[Lexical](https://lexical.dev/)ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚ŒãŒã€åˆæœŸçŠ¶æ…‹ã¯éå¸¸ã«ç°¡ç´ ã§ã™ãŒã€å®Ÿè£…ã‚’é€²ã‚ã‚Œã°ã™ã™ã‚ã‚‹ã»ã©è‰²ã€…ãªæ©Ÿèƒ½ã‚’æ­è¼‰ã§ãã‚‹ã“ã¨ãŒåˆ†ã‹ã£ã¦ãã¾ã—ãŸã€‚
ãªã®ã§ã€ä»Šå›ã¯ Lexical ã§ã§ãã‚‹ä¸€éƒ¨ã®ç´¹ä»‹ãŒã§ããŸã‚‰ã¨æ€ã„ã¾ã™ã€‚
ãŸã ã€çµæ§‹é‡ãŒè†¨å¤§ã«ãªã£ã¦ã—ã¾ã£ãŸã®ã¨ã€ãã®å‰²ã«ã¯ã¾ã¨ã¾ã£ã¦ãŠã‚‰ãšä¸Šã‹ã‚‰é †ã«ã‚ˆã‚“ã§ã‚‚ãã‚Œã£ã½ã„ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
ãªã®ã§ã€èª­ã¿ã«ãã„æ–‡ç« ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ãã‚Œã§ã‚‚ç›®ã‚’é€šã—ã¦ã„ãŸã ã‘ã‚‹æ–¹ãŒã„ã‚Œã°è¦‹ã¦ã„ãŸã ã‘ã¾ã™ã¨å¹¸ã„ã§ã™ã€‚
ãªãŠã€è¨˜äº‹ã®ä¸­ã§ä½¿ç”¨ã—ã¦ã„ã‚‹ç”»åƒã¯å¼•ç”¨å…ƒãŒè¨˜è¼‰ã—ã¦ã„ãªã„å ´åˆã€å…¨ã¦ Lexical ã®[å…¬å¼ã‚µã‚¤ãƒˆ](https://lexical.dev/)ã‹ã‚‰å¼•ç”¨ã—ã¦ãŠã‚Šã¾ã™ã€‚
ã§ã¯ã¯ã˜ã‚ã¾ã™ã€‚

# Lexical ã®æ¦‚è¦

## Lexical ã¨ã¯

Lexical ã¨ã¯ Meta ç¤¾ãŒæä¾›ã—ã¦ã„ã‚‹ Javascript ãƒ™ãƒ¼ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚
ã“ã® Lexical ã¯ä»¥ä¸‹ã®ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ã€‚
![Untitled](/images/notice-lexical-info/Untitled.png)
Lexical ã¯ã‚¨ãƒ‡ã‚£ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«çŠ¶æ…‹ã‚’æŒã£ã¦ãŠã‚Šã€ä»»æ„ã®æ™‚é–“ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
![Untitled](/images/notice-lexical-info/Untitled1.png)
[WCAG](https://waic.jp/translations/WCAG21/)ã«æº–æ‹ ã—ã¦ä½œã‚‰ã‚Œã¦ãŠã‚Šã€å…¨ã¦ã®äººã«ã¨ã£ã¦ä½¿ã„ã‚„ã™ã„æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
![Untitled](/images/notice-lexical-info/Untitled2.png)
Lexical ã¯å¿…è¦ãªæ©Ÿèƒ½ã ã‘æä¾›ã—ã¦ã„ã‚‹ã®ã§ã€ã¨ã¦ã‚‚è»½ã„ã§ã™ã€‚
å®Ÿéš›ã«[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://lexical.dev/docs/intro#:~:text=The%20core%20package%20of%20Lexical%20is%20only%2022kb%20in%20file%20size)ã§ã¯ã‚³ã‚¢æ©Ÿèƒ½ã®ã‚µã‚¤ã‚ºã¯ 22kb ã—ã‹ãªã„ã¨è¬³ã£ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ Lexical è‡ªèº«ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚„å„ã‚¨ãƒ‡ã‚£ã‚¿æ©Ÿèƒ½ãã®ã‚‚ã®ã‚’å¤šãæä¾›ã—ã¦ã„ã‚‹ã®ã§ã¯ãªãã€ã‚ãã¾ã§ä¸Šè¨˜ã«ã¤ãªãŒã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä¸»ã«æä¾›ã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚
ãªãŠã€æ©Ÿèƒ½ã«ã‚ˆã£ã¦ã¯æ‹¡å¼µã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ Lexical ã‹ã‚‰æä¾›ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€å®Œå…¨ã«ä¸€ã‹ã‚‰ã‚¨ãƒ‡ã‚£ã‚¿æ©Ÿèƒ½ã‚’çµ„ã‚€å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã¨ã¯ã„ãˆã€ã‚³ã‚¢æ©Ÿèƒ½ã«ã¤ã„ã¦ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã“ã¨ãŒä¸»ã¨ãªã£ã¦ãŠã‚Šã€ãã®ãŠã‹ã’ã§ã‹ãªã‚Šè»½ã„ã‚‚ã®ã«ãªã£ã¦ã„ã¾ã™ã€‚
![Untitled](/images/notice-lexical-info/Untitled3.png)
Javascript ãƒ™ãƒ¼ã‚¹ãªã®ã§ã€Web ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚‚ã¡ã‚ã‚“å¯¾å¿œã—ã¦ã„ã¾ã™ãŒã€iOS ç”¨ã® Swift ã«ã‚‚å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚
Android ç³»ã¯ã„ã‘ã‚‹ã®ã‹åˆ†ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
Lexical ã¯ã€ŒFastã€ã®æ©Ÿèƒ½ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã‚³ã‚¢æ©Ÿèƒ½ã¯å¿…è¦æœ€ä½é™ã—ã‹æä¾›ã—ã¦ã„ã¾ã›ã‚“ã€‚
ãã®ãŸã‚ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¾å­˜ã›ãšã‹ãªã‚Šè‡ªç”±ã«è‡ªåˆ†ãªã‚Šã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
å®Ÿéš›ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã® Introduction ã«ã‚‚ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¼‰ãŒã‚ã‚Šã¾ã™ã€‚

> Lexical allows developers to create unique text editing experiences that scale in size and functionality.

ä»¥ä¸Šã®ã“ã¨ã‹ã‚‰ã€ä¸€é€šã‚Šæ©Ÿèƒ½ãŒãã‚ã£ãŸã‚‚ã®ã‚’ã‚µã‚¯ãƒƒã¨ä½¿ã†ã®ã§ã¯ãªãã€è‡ªç”±ã«æ”¹é€ ã—ãŸã„å ´åˆã¯ Lexical ã¯ç¬¬ä¸€å€™è£œã«ãªã‚Šãã†ã§ã™ã€‚

## æ©Ÿèƒ½ã®ç‰¹å¾´

Lexical ã¯ contentEditable ãªè¦ç´ ã¨æ¥ç¶šã—ã¾ã™ã€‚
ä»¥é™ã®ç”»é¢å‹•ä½œã¯ Lexical æä¾›ã®å®£è¨€å‹ã® API çµŒç”±ã§è¡Œã‚ã‚Œã¾ã™ã€‚
ãã‚Œã«ã‚ˆã£ã¦ã€DOM ã‚’ç›´æ¥æ›¸ãæ›ãˆã‚‹ã“ã¨ã¯ã»ã¼å¿…è¦ãªããªã‚Šã€DOM çµ¡ã¿ã®ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚’å¿ƒé…ã™ã‚‹å¿…è¦ãŒãªã„ã§ã™ã€‚
ã‚¤ãƒ¡ãƒ¼ã‚¸ã¯ä»¥ä¸‹ã®ç”»åƒã®é€šã‚Šã§ã™ã€‚
![Untitled](/images/notice-lexical-info/Untitled4.png)
ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ Lexical ãŒæä¾›ã™ã‚‹æ©Ÿèƒ½ã¯ä½¿ã„ã¾ã™ãŒã€ã“ã®æ ã‚’é£›ã³è¶Šãˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒç›´æ¥ DOM ã¨ã‚„ã‚Šå–ã‚Šã™ã‚‹å¿…è¦ã¯åŸºæœ¬ãªã„ã§ã™ã€‚
ä½¿ã£ã¦ã„ã‚‹èº«ã¨ã—ã¦ã¯ã€Lexical ãŒè¨€ã£ã¦ã„ã‚‹ã“ã¨ã«ç´å¾—æ„Ÿã¯ã‚ã‚Šã¾ã™ã€‚
ãŸã ã€ç”»é¢ã®ã“ã“ã«å‡ºã—ãŸã„ã¨ã„ã£ãŸè¡¨ç¤ºã™ã‚‹ä½ç½®ã‚’çµ¶å¯¾å€¤ã§å®šã‚ã‚‹æ™‚ã¯ Lexical ã®æ©Ÿèƒ½ãƒ¡ã‚¤ãƒ³ã§ã‚„ã‚‹ã®ã¯å³ã—ã„å°è±¡ã§ã™ã€‚
Lexical ã¯ contentEditable ãªè¦ç´ ã¨ç´ã¥ã„ã¦çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã®ã§ã€ãã®å¤–ã®æƒ…å ±ãŒæ¬²ã—ã„å ´åˆã¯ Lexical ä»¥å¤–ã®æ©Ÿèƒ½ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã¨ã¯ã„ãˆã€å¤–ã®æƒ…å ±ã‚’å–å¾—ã—ãŸã‚‰ãã®å€¤ã‚’ Lexical å†…ã® State ã«ä¿å­˜ã—ã¦ãŠãã“ã¨ã¯ã§ãã¾ã™ã—ã€ã‚¨ãƒ‡ã‚£ã‚¿æ©Ÿèƒ½ã«é–¢ã—ã¦ã¯ã»ã¼ Lexical ã®å‡¦ç†ã‚’ä½¿ç”¨ã—ã¦æ§‹ç¯‰ã—ã¦ã„ã¾ã™ã€‚
ãªã®ã§ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè¨˜è¼‰ã®é€šã‚Šã‚¨ãƒ‡ã‚£ã‚¿æ©Ÿèƒ½ã¯ Lexical çµŒç”±ã®ã¿ã§å®Ÿè£…ã™ã‚‹ã®ãŒæœ€é©è§£ã ã¨æ€ã„ã¾ã™ã€‚
å…ˆç¨‹ Lexical ã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–¢ä¿‚æ€§ã‚’è»½ãã¿ã¾ã—ãŸãŒã€ã‚‚ã†å°‘ã—å…·ä½“çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã®é–¢ä¿‚ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚
ã¾ãšã¯ä»¥ä¸‹ã®ç”»é¢ã‚’è¦‹ã¦ãã ã•ã„ã€‚
![Untitled](/images/notice-lexical-info/Untitled5.png)
ä¸»ãªæµã‚Œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
â‘ contentEditable ãª DOM ã§ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹
â‘¡Lexical ãŒãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å—ã‘å–ã‚‹
â‘¢ ã‚¤ãƒ™ãƒ³ãƒˆã«ç´ã¥ã‘äºˆã‚ç™»éŒ²ã—ã¦ã„ãŸå‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹
â‘£Lexical ãŒç®¡ç†ã—ã¦ã„ã‚‹ State ã‚’æ›´æ–°ã™ã‚‹
â‘¤â‘£ ã® State ãŒç´ã¥ã„ã¦ã„ã‚‹ DOM Reconciler ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
â‘¥DOM Reconciler ã«å¤‰æ›´ãŒã‚ã‚Œã°ã€contentEditable ãª DOM ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
ãªãŠã€DOM Reconciler ã¯ä»®æƒ³ DOM ã¨ç½®ãæ›ãˆã¦ä¸Šè¨˜ã‚’èª­ã‚“ã§ã‚‚ã‚‰ã£ã¦ã‚‚å•é¡Œãªã„ã¨æ€ã£ã¦ã„ã¾ã™ã€‚
ãŸã ã—ã€[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://lexical.dev/docs/intro#:~:text=You%20can%20think%20of%20this%20as%20a%20kind%2Dof%20virtual%20DOM%2C%20except%20Lexical%20is%20able%20to%20skip%20doing%20much%20of%20the%20diffing%20work%2C%20as%20it%20knows%20what%20was%20mutated%20in%20a%20given%20update.)ã§ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¼‰ãŒã‚ã‚‹é€šã‚Šã€å®Œå…¨ã«åŒä¸€ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

> You can think of this as a kind-of virtual DOM, except Lexical is able to skip doing much of the diffing work, as it knows what was mutated in a given update.

ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã«ç‰¹åŒ–ã—ã¦ãŠã‚Šã€ãã‚Œã«é–¢ä¿‚ãªã„å·®åˆ†ã«ã¤ã„ã¦ã¯åæ˜ ã•ã›ã‚‹å‡¦ç†ã‚’è¡Œã‚ãªã„ã¨ã—ã¦ã„ã¾ã™ã€‚
ã¨ã¯ã„ãˆã€ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã«é–¢ã‚ã‚‹å·®åˆ†ã«ã¤ã„ã¦ã¯å¤‰æ›´ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ DOM ã«åæ˜ ã•ã‚Œã‚‹ã®ã§ã€æµã‚Œã¨ã—ã¦ã¯æ¦‚ã­ä»®æƒ³ DOM ã¨èªè­˜ã—ã¦ã„ã‚‚ç†è§£ã‚’å¤§ããèª¤ã‚‹ã“ã¨ã¯ãªã•ãã†ã§ã™ã€‚(é–“é•ãˆã¦ã„ãŸã‚‰ã™ã¿ã¾ã›ã‚“)

## Lexical ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆ

### ã™ã¹ã¦ã®æºï¼šEditor instances

DOM ã®ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ Lexical ã‚’çµŒç”±ã—ã€æœ€çµ‚çš„ã« DOM ã¸åæ˜ ã•ã›ã‚‹æµã‚Œã‚’è¦‹ã¦ãã¾ã—ãŸã€‚
ã“ã®æµã‚Œã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«å¿…è¦ãªã®ãŒã€Editor instances ã§ã™ã€‚
Editor instances ã‚’ç”Ÿæˆã—ã€contentEditable ãª DOM ã‚’ç´ã¥ã‘ã‚‹ã“ã¨ã§åˆã‚ã¦ã“ã‚Œã¾ã§èª¬æ˜ã—ãŸæµã‚Œã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã® Editor instances ã‚’ä½œæˆã™ã‚‹ã«ã¯ Lexical ãŒæä¾›ã—ã¦ã„ã‚‹ createEditor API ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
createEditor API ã‚’å‘¼ã³å‡ºã›ã‚‹ç’°å¢ƒã§ã‚ã‚Œã° React ã§ãªãã¦ã‚‚ã€Lexical ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ãŸã ã€`@lexical/react`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ãˆã°ã€Lexical ã®ä½¿ã†ãŸã‚ã«å¿…è¦ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆãªã©è¡Œã£ã¦ãã‚Œã‚‹ã®ã§ã€ç‰¹åˆ¥ãªäº‹æƒ…ãŒãªã„é™ã‚Šã¯ React ã§é–‹ç™ºã—ãŸæ–¹ãŒç°¡å˜ã«å¿…è¦ãªæ©Ÿèƒ½ã‚’ä½¿ãˆãã†ã§ã™ã€‚

### Lexical ã®æ ¸ï¼šEditor States

Editor instances ã«ã‚ˆã£ã¦ã€Lexical ã®æ ¸ã¨è¨€ãˆã‚‹ Editor States ã‚’æ‰±ã†ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚
Editor States ã¯[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.notion.so/Lexical-46d63373e0d0428d95090e5346dfe54a?pvs=21)ã«ä»¥ä¸‹ã®è¨˜è¼‰ãŒã‚ã‚‹ã‚ˆã†ã«ã€Lexical ã«ãŠã„ã¦ Editor Sates ãŒä¿¡é ¼ã§ãã‚‹æƒ…å ±æºã¨ãªã‚Šã¾ã™ã€‚

> With Lexical, the source of truth is not the DOM, but rather an underlying state model that Lexical maintains and associates with an editor instance.

ãªã®ã§ã€Lexical ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã ã‚Šã€æ›¸ãè¾¼ã‚“ã ã‚Šã™ã‚‹ã“ã¨ã¯ Editor States ã®æƒ…å ±ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¨ç­‰ã—ã„ã§ã™ã€‚
ã“ã®ã€Editor States ã¯å¤§ããåˆ†ã‘ã¦ä»¥ä¸‹ã®äºŒã¤ã®æƒ…å ±ã‚’ã‚‚ã£ã¦ã„ã¾ã™ã€‚
â‘ Lexical ã® Node ãƒ„ãƒªãƒ¼
â‘¡Lexical ã® Selection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
Node ã¯ã‚¨ãƒ‡ã‚£ã‚¿å†…ã§æ§‹ç¯‰ã•ã‚Œã‚‹è¦ç´ ã§ã™ã€‚
ã‚¤ãƒ¡ãƒ¼ã‚¸ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å„ HTML è¦ç´ ä¸€ã¤ãŒä¸€ã¤ã® Node ã¨ã—ã¦æ‰ãˆã¦ã„ã¾ã™ã€‚

```html
<div>
  <p>
    <span>Lexical</span>
  </p>
</div>
```

ã‚‚ã¡ã‚ã‚“æ­è¼‰ã§ãã‚‹æ©Ÿèƒ½ã¯ HTML ã¨ã¯å…¨ãé•ã„ã¾ã™ã€‚
ã§ã™ãŒã€Lexical ã§ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ç”Ÿæˆã—ãŸã‚‰ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚Œã‚‹ RootNode ã‚’ã¯ã˜ã‚ã¨ã—ã€ãã“ã‹ã‚‰å…¥ã‚Œå­æ§‹é€ ã§ Node ãŒçµ„ã¿ç«‹ã¦ã‚‰ã‚Œã‚‹ã®ã¯ HTML ã®æ§‹é€ ã«ä¼¼ã¦ã„ã‚‹ã¨æ„Ÿã˜ã¾ã™ã€‚
Selection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç¾åœ¨é¸æŠã—ã¦ã„ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã®æƒ…å ±ã‚„ Node ã®æƒ…å ±ã‚’æŒã£ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€æ–‡å­—ã‚’é¸æŠã—ã¦ã„ã‚‹ã¨ãã«ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¡¨ç¤ºã•ã›ã‚‹ãªã©ã€é¸æŠç¯„å›²ã«å¯¾ã™ã‚‹æ“ä½œã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
Editor States ãŒæŒã¤æƒ…å ±ã«ã¤ã„ã¦ç¢ºèªã—ã¾ã—ãŸãŒã€å­˜åœ¨ã™ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã«ã¤ã„ã¦ã‚‚ç¢ºèªã—ã¾ã™ã€‚
ã“ã‚Œã«ã¤ã„ã¦ã‚‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¯ä»¥ä¸‹ã®è¨˜è¼‰ãŒã‚ã‚Šã¾ã™ã€‚

> - During an update they can be thought of as "mutable". See "Updating state" below to mutate an editor state.
> - After an update, the editor state is then locked and deemed immutable from there on. This editor state can therefore be thought of as a "snapshot".

Lexical ã®æ§‹æ–‡å†…ã§æ›´æ–°å‡¦ç†ã‚’ã—ã¦ã„ã‚‹å ´åˆã¯æ“ä½œå¯èƒ½ã¨ãªã‚Šã€æ›´æ–°å¾Œã¯ç¾åœ¨ã®çŠ¶æ…‹ã‚’ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã«ä¿æŒã—ã¦ã„ã¾ã™ã€‚
Lexical ã®ä¸–ç•Œã®ä¸­ã§ã—ã‹ Editor States ã¯æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ããªã„ã®ã§ã€Editor States ã¯ Lexical ã«ãŠã„ã¦ç¾åœ¨ã®çŠ¶æ…‹ã‚’æ­£ã—ãä¿æŒã—ã¦ã„ã‚‹ã¨ã¿ãªã›ã¾ã™ã€‚
ã“ã“ã¾ã§ã§ Editor States ãŒä¿æŒã™ã‚‹æƒ…å ±ã¨ã¨ã‚Šã†ã‚‹çŠ¶æ…‹ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
æœ€å¾Œã« Editor States ã®æƒ…å ±ã‚’å–å¾—ã—ãŸã‚Šã€æ›´æ–°ã—ãŸã‚Šã™ã‚‹éš›ã®æ‰‹é †ã‚’ç¢ºèªã—ã¾ã™ã€‚
[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://lexical.dev/docs/concepts/editor-state)ã«ã¯ã‚‚ã¡ã‚ã‚“æ§˜ã€…ãªæ–¹æ³•ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™ãŒã€ã¨ã‚Šã‚ãˆãšä»¥ä¸‹ã®ç‚¹ã ã‘æŠŠæ¡ã—ã¦ãŠã‘ã°ã–ã£ãã‚Šã¨é–‹ç™ºãŒã§ãã‚‹ã¨æ€ã„ã¾ã™ã€‚(å®Ÿéš›ã¯ã§ããšã€ç§ãŒã§ãã‚‹ã¨å‹˜é•ã„ã—ã¦ã„ã‚‹ã ã‘ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒâ€¦ã€‚)
â‘  ç¾åœ¨ã® Editor States ã‚’å–å¾—ã™ã‚‹æ™‚ã¯`getEditorState`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
â‘¡ æ›´æ–°å‡¦ç†ã‚’ã™ã‚‹æ™‚ã¯`update`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
â‘¢ æ›´æ–°ã‚’æ¤œçŸ¥ã—ã¦å‡¦ç†ã‚’å®Ÿè¡Œã—ãŸã„å ´åˆã¯`registerUpdateListener`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹
â‘£Lexical ã®ä¾¿åˆ©ãªé–¢æ•°ç¾¤ã¯`update`ãƒ¡ã‚½ãƒƒãƒ‰ã‹`read`ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã—ã‹å®Ÿè¡Œã§ããªã„
å…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰ä¾‹ã¯å¾Œã»ã©å®Ÿè£…ä¾‹ã®æ™‚ã«è¨˜è¼‰ã—ã¾ã™ãŒã€ã“ã“ã§ã¯ä¾¿åˆ©ãªé–¢æ•°ç¾¤ã«ã¤ã„ã¦ã¿ã¦ã„ãã¾ã™ã€‚
Lexical ã§ã¯ç¾åœ¨ã® Node ã‚’å–å¾—ã™ã‚‹ã§ã‚ã£ãŸã‚Šã€Selection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã®å–å¾—ã§ã‚ã£ãŸã‚Šã€æ–°ã—ã Node ã‚’ä½œã‚‹ã§ã‚ã£ãŸã‚Šã€Editor States å†…éƒ¨ã®æ“ä½œã«å¯¾ã—ã¦ã„æ§˜ã€…ãªæ©Ÿèƒ½ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãã—ã¦ã€ãã‚Œã‚‰ã¯å…¨ã¦æ¥é ­è¾ã¨ã—ã¦`$`ãŒä»˜ä¸ã•ã‚Œã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚

```tsx
import { $getRoot, $getSelection } from "lexical";
import { $createParagraphNode } from "lexical";
editor.update(() => {
  // Get the RootNode from the EditorState
  const root = $getRoot();
  // Get the selection from the EditorState
  const selection = $getSelection();
  // Create a new ParagraphNode
  const paragraphNode = $createParagraphNode();
  // Create a new TextNode
  const textNode = $createTextNode("Hello world");
  // Append the text node to the paragraph
  paragraphNode.append(textNode);
  // Finally, append the paragraph to the root
  root.append(paragraphNode);
});
```

Node ã‚’ä½œæˆã—ãŸã‚Šã€Selection ã‚’å–å¾—ã—ã¦ã„ã¾ã™ã­ã€‚
å®Ÿéš›ã«é–‹ç™ºã™ã‚‹ã¨ã€`$`ãŒã¤ã„ãŸé–¢æ•°ç¾¤ã¯ Lexical ã§é–‹ç™ºã™ã‚‹éš›ã«å¿…é ˆã§ã™ã€‚
ã“ã‚Œã‚‰ãŒãªã„ã¨ Lexical ã§ã®é–‹ç™ºã¯ç„¡ç†ã ã¨è¨€ã£ã¦ã‚‚éè¨€ã§ã¯ãªã„ãã‚‰ã„ã€ä¾¿åˆ©ãªé–¢æ•°é”ã§ã™ã€‚
ã§ã™ãŒã€ã“ã‚Œã‚‰é–¢æ•°ã¯ Lexical ã® update ãƒ¡ã‚½ãƒƒãƒ‰ã‹ read ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§ã—ã‹ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚
ãã‚Œä»¥å¤–ã§ã¯å‹•ä½œã—ãªã„ã®ã§ã€æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚

# Lexical ã‚’ä½¿ã£ã¦ä»Šé–‹ç™ºã—ã¦ã„ã‚‹ã“ã¨ã‚’ã¤ã‚‰ã¤ã‚‰ã¨æ›¸ã

ã“ã“ã‹ã‚‰ã¯å®Ÿéš›ã« Lexical ã‚’ä½¿ã£ã¦é–‹ç™ºã‚’ã—ã¦ã„ãã¾ã™ã€‚
æœ¬å½“ã¯é †åºã ã£ã¦è¨˜è¼‰ã—ã¦ã„ããŸã‹ã£ãŸã®ã§ã™ãŒã€ã¾ã¨ã‚ã‚‹æ°—åŠ›ãŒã‚ã‹ãšå„ç¯€ãŒå¾®å¦™ã«ç‹¬ç«‹ã—ã¦ã„ã‚‹å½¢ã«ãªã£ã¦ã„ã¾ã™ã€‚
èª­ã¿ã«ããã¦ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚
ãªãŠã€å¤§æ ã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
https://zenn.dev/stin/articles/lexical-rich-editor-trial
ä»Šå›ç§ãŒå®Ÿè£…ã—ã¦ãã‚¨ãƒ‡ã‚£ã‚¿ã¯ Next.js ã® App Router ã‚’ä½¿ç”¨ã—ã¤ã¤ã€ã“ã®è¨˜äº‹ã‚’æ‹¡å¼µã—ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚
è¨˜äº‹å†…ã«ã‚ã‚‹`$wrapLeafNodesInElements`ã¯ç¾åœ¨ã® Lexical ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
ãã®ãŸã‚ã€ãã®éƒ¨åˆ†ã«é–¢ã—ã¦ç§ã¯`$setBlocksType`ã‚’ä½¿ã„å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
$wrapLeafNodesInElements ã¨ã®äº’æ›æ€§ãŒã‚ã‚‹ã‹ã¯ã‚ã‹ã‚Šã¾ã›ã‚“ãŒã€å°‘ãªãã¨ã‚‚åŒç­‰ã®å‹•ãã¯ã—ã¾ã™ã€‚
ã¾ãŸã€å‚è€ƒè¨˜äº‹ã§ã¯ SCSS ã§ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã‚ã¦ã¦ã„ã¾ã™ãŒã€ä»Šå¾Œã®ã‚³ãƒ¼ãƒ‰ã§ã¯ Tailwind CSS ã§ã‚ã£ãŸã‚Šã€CSS Modules ã§ã‚ã£ãŸã‚Šã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ç‰¹ã«æ„å›³ã¯ãªãã€å˜ç´”ã«è©¦ã—ãŸã“ã¨ãŒæ··åœ¨ã—ã¦ã„ã‚‹ã ã‘ã§ä»Šå¾Œã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¯¾è±¡ã«ãªã£ã¦ã„ã¾ã™ã€‚

## Markdown å¤‰æ›ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¿½åŠ ã™ã‚‹

ç¾çŠ¶ Lexical ã¯åŸºæœ¬çš„ãª Markdown å¤‰æ›ã«ã¯å¯¾å¿œã—ã¦ãŠã‚Šã€ãã®ã¾ã¨ã¾ã‚Šã¨ã—ã¦`TRANSFORMERS`ã¨ã„ã†å¤‰æ•°ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã§ã™ãŒã€å ´åˆã«ã‚ˆã£ã¦ã¯ç‹¬è‡ªã§ Markdonw ã®å¤‰æ›ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¿½åŠ ã—ãŸã„å ´åˆãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚
ãã®æ™‚ã®æ‰‹é †ã«ã¤ã„ã¦ç¢ºèªã—ã¾ã™ã€‚
ã¾ãšå¤‰æ›ã®ç¨®é¡ã§ã™ãŒã€[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://lexical.dev/docs/packages/lexical-markdown)ã‚’ç¢ºèªã™ã‚‹ã¨ä»¥ä¸‹ã® 3 ã¤ãŒã‚ã‚Šã¾ã™ã€‚

- **Element transformer**
- **Text format transforme**
- **Text match transformer**

æ­£ç›´å³å¯†ãªé•ã„ã¯åˆ†ã‹ã£ã¦ã„ã¾ã›ã‚“ãŒã€Element transformer ã¯ãƒ–ãƒ­ãƒƒã‚¯å˜ä½ã§ã®å¤‰æ›ã€‚
Text format transforme ã¯ Node ã®å¤‰æ›ã¯ã›ãšã€ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ã¿ã‚’å¤‰æ›ã€‚
Text match transformer ã¯ãƒ†ã‚­ã‚¹ãƒˆã®ä¸€éƒ¨ã‚’å¤‰æ›ã€‚
ã¨ã„ã£ãŸæ„Ÿã˜ã§åŒºåˆ¥ã—ã¦ã„ã¾ã™ã€‚
åŸºæœ¬çš„ã«ã¯ã“ã‚Œã‚‰ã®å¤‰æ›ã‚’å®šç¾©ã—ã€ãã‚Œã‚’ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¸ç™»éŒ²ã™ã‚‹æµã‚Œã¨ãªã‚Šã¾ã™ã€‚
ã–ã£ãã‚Šã¨ã—ã¦èª¬æ˜ã‚’ã—ãŸã®ã§ã€ç¾åœ¨ç§ãŒå®Ÿè£…ã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å±•é–‹ã—ã¾ã™ã€‚

```tsx
import {
  TRANSFORMERS,
  TextMatchTransformer,
  ElementTransformer,
} from "@lexical/markdown";
import { MarkdownShortcutPlugin } from "@lexical/react/LexicalMarkdownShortcutPlugin";
import {
  $createImageNode,
  $isImageNode,
  ImageNode,
} from "./InserImagePlugin/node";
import {
  $createCollapsibleContainerNode,
  $isCollapsibleContainerNode,
  CollapsibleContainerNode,
} from "./CollapsiblePlugin/container-node";
import {
  $createCollapsibleContentNode,
  $isCollapsibleContentNode,
  CollapsibleContentNode,
} from "./CollapsiblePlugin/content-node";
import {
  $createCollapsibleTitleNode,
  $isCollapsibleTitleNode,
  CollapsibleTitleNode,
} from "./CollapsiblePlugin/title-node";
import {
  $createParagraphNode,
  $createTextNode,
  $isParagraphNode,
  ElementNode,
  LexicalNode,
} from "lexical";
import {
  $createLinkPreviewNode,
  $isLinkPreviewNode,
  LinkPreviewNode,
} from "./LinkPreviewPlugin/node";
import {
  $createMessageContentNode,
  $isMessageContentNode,
  MessageContentNode,
  MessageTypes,
} from "./MessagePlugin/content-node";
import { Permutation } from "@/libs/utility-types";
import {
  TableNode,
  TableCellNode,
  TableRowNode,
  $isTableNode,
  $createTableNode,
  $createTableRowNode,
  $createTableCellNode,
} from "@lexical/table";
import {
  $isFigmaNode,
  FigmaNode,
} from "./EmbedExternalSystemPlugin/FigmaPlugin/node";
import {
  $isTweetNode,
  TweetNode,
} from "./EmbedExternalSystemPlugin/TwitterPlugin/node";
export const IMAGE: TextMatchTransformer = {
  dependencies: [ImageNode],
  export: (node, exportChildren, exportFormat) => {
    if (!$isImageNode(node)) {
      return null;
    }
    return `![${node.getAltText()}](${node.getSrc()})`;
  },
  importRegExp: /!(?:\[([^[]*)\])(?:\(([^(]+)\))/,
  regExp: /!(?:\[([^[]*)\])(?:\(([^(]+)\))$/,
  replace: (textNode, match) => {
    const [, altText, src] = match;
    const imageNode = $createImageNode({ src, altText, maxWidth: 800 });
    textNode.replace(imageNode);
  },
  trigger: ")",
  type: "text-match",
};
export const COLLAPSIBLE: ElementTransformer = {
  dependencies: [
    CollapsibleContainerNode,
    CollapsibleContentNode,
    CollapsibleTitleNode,
  ],
  export: (node, exportChildren: (node: ElementNode) => string) => {
    if (!$isCollapsibleContainerNode(node)) {
      return null;
    }
    const titleNode = node.getFirstChild();
    const contentNode = node.getLastChild();
    if (
      !$isCollapsibleTitleNode(titleNode) ||
      !$isCollapsibleContentNode(contentNode)
    ) {
      return null;
    }
    const title = exportChildren(titleNode);
    const content = exportChildren(contentNode);
    return ":::details " + title + "\n" + content + "\n:::";
  },
  replace: (parentNode: ElementNode, children: LexicalNode[], match) => {
    const [all, title, content] = match;
    const messageContainer = $createCollapsibleContainerNode(true);
    const messageTitle = $createCollapsibleTitleNode().append(
      $createTextNode(all.replace(":::details ", "").trim())
    );
    const messageContent = $createCollapsibleContentNode().append(
      $createParagraphNode()
    );
    // childrenã‚’ParagraphNodeã«ãƒ©ãƒƒãƒ—ã—ã¦messageContentã«è¿½åŠ 
    children.forEach((child) => {
      if ($isParagraphNode(child)) {
        messageContent.append(child);
      } else {
        const paragraphNode = $createParagraphNode();
        paragraphNode.append(child);
        messageContent.append(paragraphNode);
      }
    });
    messageContainer.append(messageTitle, messageContent);
    parentNode.replace(messageContainer);
  },
  regExp: /^[ \t]*:::details [\s\S]+(\w{1,10})?\s/,
  type: "element",
};
export const MESSAGE: ElementTransformer = {
  dependencies: [MessageContentNode],
  export: (node, exportChildren: (node: ElementNode) => string) => {
    if (!$isMessageContentNode(node)) {
      return null;
    }
    return (
      ":::message " +
      node.getMessageType() +
      "\n" +
      node.getTextContent() +
      "\n:::"
    );
  },
  replace: (parentNode: ElementNode, children: LexicalNode[], match) => {
    const [all] = match;
    const trimMathcText = all.replace(":::message ", "").trim();
    const messageTypes: Permutation<MessageTypes> = ["alert", "warning", ""];
    const targetMessageType = messageTypes.find(
      (type) => type === trimMathcText
    );
    if (targetMessageType === undefined) {
      return null;
    }
    const messageContent = $createMessageContentNode(targetMessageType);
    parentNode.replace(messageContent);
  },
  regExp: /^[ \t]*:::message (\s|alert|warning)\s/,
  type: "element",
};
export const LINK_CARD: ElementTransformer = {
  dependencies: [LinkPreviewNode],
  export: (node) => {
    if (!$isLinkPreviewNode(node)) {
      return null;
    }
    return "@[linkCard](" + node.getUrl() + ")";
  },
  replace: (node, children, match) => {
    const [, url] = match;
    const linkPreviewNode = $createLinkPreviewNode({ url });
    node.replace(linkPreviewNode);
  },
  regExp: /@(?:\[linkCard\])(?:\(([^(]+)\))$/,
  type: "element",
};
export const TABLE: ElementTransformer = {
  dependencies: [TableNode, TableRowNode, TableCellNode],
  export: (node) => {
    if (!$isTableNode(node)) {
      return null;
    }
    const separate = " | ";
    const children = node.getChildren();
    const childrenTexts = children.map((child) =>
      child
        .getTextContent()
        .split("\n")
        .map((val, index) => (index % 2 === 1 ? " | " : `${val}`))
    );
    const headerSeparete = [
      ...Array(childrenTexts[0].filter((i) => i !== separate).length),
    ]
      .map(() => "----")
      .join(separate);
    const headerText = childrenTexts[0].join("");
    const bodyTexts = childrenTexts.slice(1).map((val) => {
      return `| ${val.join("")} |`;
    });
    const bodyText = bodyTexts.join("\n");
    return `| ${headerText} |\n| ${headerSeparete} |\n${bodyText}`;
  },
  replace: (parentNode: ElementNode, children: LexicalNode[], match) => {
    const [all] = match;
    const createRowNum = Number(all.replace(/.*\|/gi, "").trim());
    const tabeleCotent = all.trim().match(/^\|.*\|/gi);
    if (!tabeleCotent) {
      return;
    }
    const texts = tabeleCotent[0]
      .replace(/^\|/, "")
      .replace(/\|$/, "")
      .split("|");
    const tableNode = $createTableNode();
    const tableRowNode = $createTableRowNode();
    const tableCellNodes = texts.map((text) =>
      $createTableCellNode(0).append(
        $createParagraphNode().append($createTextNode(text.trim()))
      )
    );
    tableCellNodes.forEach((cell) => {
      tableRowNode.append(cell);
    });
    tableNode.append(tableRowNode);
    for (let i = 1; i < createRowNum; i++) {
      const tableRowNodeArterFirstRow = $createTableRowNode();
      [...Array(tableCellNodes.length)].forEach((_) => {
        tableRowNodeArterFirstRow.append(
          $createTableCellNode(0).append($createParagraphNode())
        );
      });
      tableNode.append(tableRowNodeArterFirstRow);
    }
    return parentNode.replace(tableNode);
  },
  regExp: /^\|.+\| (\s|[0-9]+)\s/g,
  type: "element",
};
export const FIGMA: ElementTransformer = {
  dependencies: [FigmaNode],
  export: (node) => {
    if (!$isFigmaNode(node)) {
      return null;
    }
    return "@[figma](" + node.getTextContent() + ")";
  },
  // ã“ã“ã‹ã‚‰ä¸‹ã¯ä¸€æ—¦ä½¿ã‚ãªã„
  replace: (node, match) => {},
  regExp: /figma/,
  type: "element",
};
export const TWITTER: ElementTransformer = {
  dependencies: [TweetNode],
  export: (node) => {
    if (!$isTweetNode(node)) {
      return null;
    }
    return "----tweetEmbed----(" + node.getUrl() + ")";
  },
  // ã“ã“ã‹ã‚‰ä¸‹ã¯ä¸€æ—¦ä½¿ã‚ãªã„
  replace: (node, match) => {},
  regExp: /twitter/,
  type: "element",
};
export const TRANSFORMER_PATTERNS = [
  FIGMA,
  TWITTER,
  IMAGE,
  COLLAPSIBLE,
  LINK_CARD,
  MESSAGE,
  TABLE,
  ...TRANSFORMERS,
];
export const MarkdownPlugin = () => {
  return (
    <MarkdownShortcutPlugin
      transformers={TRANSFORMER_PATTERNS}
    ></MarkdownShortcutPlugin>
  );
};
```

åŸºæœ¬çš„ãªå®Ÿè£…ã¯ä»¥ä¸‹ã«é›†ç´„ã•ã‚Œã¾ã™ã€‚
**å¤‰æ›ã®è¨­å®šã‚’å®šç¾©ã™ã‚‹**
å…ˆç¨‹ç´¹ä»‹ã—ãŸ 3 ã¤ã® Tranformer ãŒ Markdown å‘¨ã‚Šã§ã€ä¸»ã«ä½¿ã†ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚

```tsx
export type ElementTransformer = {
  dependencies: ä½¿ç”¨ã™ã‚‹æƒ³å®šã®Node;
  export: Markdownã¨ã—ã¦å‡ºåŠ›ã—ãŸã„æ™‚ã®å¤‰æ›å‡¦;
  regExp: å¤‰æ›å‡¦ç†ã‚’èµ°ã‚‰ã›ãŸã„å ´åˆã®æ­£è¦è¡¨ç¾;
  replace: regExpã«è©²å½“ã™ã‚‹ã‚‚ã®ã‚’Lexicalã®è¦ç´ ã«å¤‰æ›ã™ã‚‹;
  type: "element";
};
export type TextFormatTransformer = Readonly<{
  format: ReadonlyArray<TextFormatType>;
  tag: string;
  intraword?: boolean;
  type: "text-format";
}>;
export type TextMatchTransformer = Readonly<{
  dependencies: ä½¿ç”¨ã™ã‚‹æƒ³å®šã®Node;
  export: Markdownã¨ã—ã¦å‡ºåŠ›ã—ãŸã„æ™‚ã®å¤‰æ›å‡¦;
  importRegExp: Markdonwã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹æ™‚ã«å¤‰æ›å‡¦ç†ã‚’èµ°ã‚‰ã›ã‚‹ãŸã‚ã®æ­£è¦è¡¨ç¾;
  regExp: å¤‰æ›å‡¦ç†ã‚’èµ°ã‚‰ã›ãŸã„å ´åˆã®æ­£è¦è¡¨ç¾;
  replace: regExpã«è©²å½“ã™ã‚‹ã‚‚ã®ã‚’Lexicalã®è¦ç´ ã«å¤‰æ›ã™ã‚‹;
  trigger: å¤‰æ›å‡¦ç†ã‚’èµ°ã‚‰ã›ã‚‹æ™‚ã®å…¥åŠ›å€¤;
  type: "text-match";
}>;
```

ä½¿ã† Lexical ã®è¦ç´ ã‚’æŒ‡å®šã—ã€ãã‚Œã‚‰ã‚’æ¤œçŸ¥ã™ã‚‹æ­£è¦è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚
ãã—ã¦ã€æ­£è¦è¡¨ç¾ã¨ä¸€è‡´ã—ãŸæ™‚ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’å®šç¾©ã—ã€Markdown ã«å‡ºåŠ›ã™ã‚‹æ™‚ã®å‡¦ç†ã‚‚æ›¸ã„ã¦ãŠãã¾ã™ã€‚
å¾Œã¯`MarkdownShortcutPlugin`ã® transformers å±æ€§ã«å€¤ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ã™ã€‚
å®Ÿéš›ã«å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€Node ã‚’ä½œæˆã™ã‚‹ãªã©äº‹å‰æº–å‚™ã‚„ãŠä½œæ³•ã¯ç†è§£ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€å¤§ã¾ã‹ãªæµã‚Œã¯ä¸Šè¨˜ã®é€šã‚Šã§ã™ã€‚
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ä¸€ç•ªåˆ†ã‹ã‚Šã‚„ã™ã„ã®ã¯ LINK_CARD ã‹ãªã¨æ€ã„ã¾ã™ã€‚

```tsx
export const LINK_CARD: ElementTransformer = {
  dependencies: [LinkPreviewNode],
  export: (node) => {
    if (!$isLinkPreviewNode(node)) {
      return null;
    }
    return "@[linkCard](" + node.getUrl() + ")";
  },
  replace: (node, children, match) => {
    const [, url] = match;
    const linkPreviewNode = $createLinkPreviewNode({ url });
    node.replace(linkPreviewNode);
  },
  regExp: /@(?:\[linkCard\])(?:\(([^(]+)\))$/,
  type: "element",
};
```

ã“ã“ã§ã¯ LinkPreviewNode ã‚’ Markdown ã§æ‰±ã†ã¨å®šç¾©ã—ã€export ã§ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã«å¤‰æ›ã™ã‚‹æ™‚ã®æ–‡å­—åˆ—ã‚’`@[linkCard](LinkPreviewNodeãŒã‚‚ã¤URL)`ã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚
replace ã§ã¯æ­£è¦è¡¨ç¾ã«ä¸€è‡´ã—ãŸæ™‚ã€æ­£è¦è¡¨ç¾ã‹ã‚‰æŠ½å‡ºã—ãŸå€¤ã‚’ä½¿ã„ LinkPreviewNode ã‚’ä½œæˆã—ã€å…ƒã® Node ã«å¯¾ã—ã¦ç½®ãæ›ãˆã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚
å¾Œã¯ã€å¤‰æ›ã®ã‚­ãƒ¼ã¨ãªã‚‹æ­£è¦è¡¨ç¾ã‚’è¨­å®šã—ã€Element ã«å¯¾ã™ã‚‹å¤‰æ›å‡¦ç†ã ã¨åˆ†ã‹ã‚‹ã‚ˆã†ã« type ã¸`element`ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚
å®Ÿè£…ã—ã¦ã¿ãªã„ã¨é›°å›²æ°—ã¯æ´ã¿ã«ãã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€é›°å›²æ°—ãŒã¤ã‹ã‚ãŸã‚‰ã‚„ã‚‹ã“ã¨ã¯å¤§ä½“åŒã˜ãªã®ã§ã€æ„å¤–ã¨ç‹¬è‡ªã® Markdown ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯é›£ã—ããªã„ã§ã™ã€‚
ä»¥ä¸ŠãŒ Markdonw ã«è¿½åŠ æ©Ÿèƒ½ã‚’æ­è¼‰ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã§ã—ãŸã€‚
ãªãŠã€TextMatchTransformer ã«ã¯ importRegExp ã¨ regExp å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚
importRegExp å±æ€§ã«ã¤ã„ã¦ã¯ã€[$convertFromMarkdownString](https://github.com/facebook/lexical/blob/2194888d29d69df74e5acae07bdec5c6f50ac6a0/packages/lexical-markdown/src/index.ts#L71C10-L71C36)ã‹ã‚‰è¾¿ã‚‹ã¨ä½¿ã‚ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã™ã€‚
ãªã®ã§ã€ä¸Šè¨˜å±æ€§ã¯ãŠãã‚‰ã Markdown ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€Lexical ã®è¦ç´ ã¸å¤‰æ›ã™ã‚‹æ™‚ã«ä½¿ç”¨ã•ã‚Œã¦ã„ãã†ã§ã™ã€‚
ä¸€æ–¹ã€regExp å±æ€§ã¯[runTextMatchTransformers](https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownShortcuts.ts#L77)é–¢æ•°ã§ä½¿ç”¨ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯ã‚¨ãƒ‡ã‚£ã‚¿ã§ Markdown å…¥åŠ›ã—ãŸæ™‚ã«ä¸€è‡´ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Œã°ã€å¯¾è±¡ã®è¦ç´ ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’ã«ãªã£ã¦ã„ã¾ã™ã€‚
ãªã®ã§ã€regExp å±æ€§ã¯ã‚¨ãƒ‡ã‚£ã‚¿ã®å…¥åŠ›ã®éš›ã«ä½¿ç”¨ã™ã‚‹æƒ³å®šã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚
æ­£ç›´ãªãœã€TextMatchTransformer ã ã‘ã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ã¨å…¥åŠ›ç”¨ã§æ­£è¦è¡¨ç¾ã‚’è¨­å®šã—ãªã„ã¨ã„ã‘ãªã„ã‹ã¯ãƒãƒƒã‚­ãƒªã¨ã¯åˆ†ã‹ã£ã¦ã„ã¾ã›ã‚“ã€‚
åˆ†ã‹ã‚‹æ–¹ãŒã„ã‚‰ã£ã—ã‚ƒã‚Œã°æ•™ãˆã¦æ¬²ã—ã„ã§ã™ã€‚ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ã€‚
æœ€å¾Œã«ã“ã®éƒ¨åˆ†ã®å®Ÿè£…ã§ã“ã‚“ãªæ„Ÿã˜ã®æŒ™å‹•ãŒé”æˆã§ãã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€ãƒ‡ãƒ¢ã‚’ãŠã„ã¦ãŠãã¾ã™ã€‚
![blog-demo-markdown.gif](/images/notice-lexical-info/blog-demo-markdown.gif)

## è‰²ä»˜ãè¦‹å‡ºã—ã®å®Ÿè£…

å…ˆç¨‹ã®ãƒ‡ãƒ¢ã§æœ€å¾Œã«è¡¨ç¤ºã—ãŸè‰²ä»˜ãã§å…ˆé ­ã«ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä»˜ä¸ã™ã‚‹ Node ã®å®Ÿè£…ã«ã¤ã„ã¦ã§ã™ã€‚
ä¸»ã«å®Ÿéš›ã®å¤‰æ›å‡¦ç†éƒ¨åˆ†ã‚’æ‹…ã† Plugin éƒ¨åˆ†ã¨è¡¨ç¤ºã®éš›ã«ä½¿ç”¨ã™ã‚‹ Node éƒ¨åˆ†ã®å®Ÿè£…ã‚’ã—ã¦ã„ã¾ã™ã€‚
ã¾ãšã¯ Plugin éƒ¨åˆ†ã«ã¤ã„ã¦ã§ã™ã€‚

```tsx
import "./styles/style.module.css";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { mergeRegister } from "@lexical/utils";
import {
  $getSelection,
  $isRangeSelection,
  COMMAND_PRIORITY_LOW,
  createCommand,
} from "lexical";
import { useEffect } from "react";
import {
  $createMessageContentNode,
  $isMessageContentNode,
  MessageContentNode,
  MessageTypes,
} from "./content-node";
import { getSelectedNode } from "../../utils/getSelectedNode";
export const INSERT_MESSEAGE_COMMAND = createCommand<MessageTypes>();
export default function MessagePlugin(): null {
  const [editor] = useLexicalComposerContext();
  useEffect(() => {
    if (!editor.hasNodes([MessageContentNode])) {
      throw new Error(
        "MessagePlugin: MessageContentNode not registered on editor"
      );
    }
    return mergeRegister(
      editor.registerCommand(
        INSERT_MESSEAGE_COMMAND,
        (payload) => {
          editor.update(() => {
            const selection = $getSelection();
            if ($isRangeSelection(selection)) {
              const node = getSelectedNode(selection).getParentOrThrow();
              if ($isMessageContentNode(node)) {
                return node.replace($createMessageContentNode(payload));
              }
              selection.insertNodes([$createMessageContentNode(payload)]);
            }
          });
          return true;
        },
        COMMAND_PRIORITY_LOW
      )
    );
  }, [editor]);
  return null;
}
```

è¡Œã£ã¦ã„ã‚‹ã®ã¯ã€Editor States ãªã©ã®æƒ…å ±ã‚’æŒã£ã¦ã„ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã€å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¦ã„ã¾ã™ã€‚
å‚è€ƒè¨˜äº‹ã«ã‚‚ã‚ã‚Šã¾ã™ãŒã€registerCommand ã§ç™»éŒ²ã—ãŸå‡¦ç†ã¯ dispatchCommand ã‚’å‘¼ã¶ã“ã¨ã§å®Ÿè¡Œã§ãã¾ã™ã€‚
çµæ§‹èé€šãŒåˆ©ãã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼çš„ãªèªè­˜ã§ç§ã¯ã„ã¾ã™ã€‚
registerCommand ã¯ç¬¬ä¸€å¼•æ•°ã«ã‚³ãƒãƒ³ãƒ‰åˆæœŸè¨­å®šã‚’å®šç¾©ã—ã¾ã™ã€‚
ãã—ã¦ã€å…·ä½“çš„ã«ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†ã‚’ç¬¬äºŒå¼•æ•°ã«è¨˜è¼‰ã—ã¾ã™ã€‚
ç¬¬äºŒå¼•æ•°ã® payload ã¯ã‚³ãƒãƒ³ãƒ‰ã®åˆæœŸè¨­å®šã‚’ã™ã‚‹éš›ã«æŒ‡å®šã—ãŸå‹ãŒå…¥ã£ã¦ãã¾ã™ã€‚

```tsx
export const INSERT_MESSEAGE_COMMAND = createCommand<MessageTypes>();
```

ä»Šå›ã§ã„ã†ã¨ MessageTypes å‹ãŒ payload ã§å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
å‡¦ç†ã®å†…å®¹ã«ã¤ã„ã¦ã¯ Selection ãŒå­˜åœ¨ã™ã‚‹å ´æ‰€ãŒè‰²ä»˜ãè¦‹å‡ºã—ã§ã‚ã‚‹ã‹ãªã„ã‹ã§ã€å‡¦ç†ã‚’åˆ†ã‘ã¦ã„ã¾ã™ã€‚
è‰²ä»˜ãè¦‹å‡ºã—ã§ãªã„å ´åˆã¯ã€ã‚­ãƒ£ãƒ¬ãƒƒãƒˆãŒé¸æŠã—ã¦ã„ã‚‹æ®µè½ã«è‰²ä»˜ãè¦‹å‡ºã—ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚
è‰²ä»˜ãè¦‹å‡ºã—ä¸Šã«ã„ã‚‹å ´åˆã¯ã€è‰²ä»˜ãè¦‹å‡ºã—ã®ç¨®é¡ã‚’å¤‰æ›´ã—ã¾ã™ã€‚
ã¾ã‚ã€åˆ†å²çš„ã«ã¯åŒã˜ã‚‚ã®ã§ã‚ã£ã¦ã‚‚ç½®ãæ›ãˆå‡¦ç†ã¯èµ°ã‚‹ã®ã§ã™ãŒã€ãã‚Œã¯è¨±å®¹ã—ã¦ã„ã¾ã™ã€‚
Plugin éƒ¨åˆ†ã‚’è¦‹ãŸã®ã§ã€æ¬¡ã¯ Node ã®å®šç¾©ã‚’ã¿ã¦ã„ãã¾ã™ã€‚

```tsx
import {
  $applyNodeReplacement,
  $createLineBreakNode,
  $createParagraphNode,
  $createTextNode,
  $isTextNode,
  DOMConversionOutput,
  DOMExportOutput,
  EditorConfig,
  ElementNode,
  LexicalNode,
  ParagraphNode,
  RangeSelection,
  SerializedElementNode,
  Spread,
  TextNode,
} from "lexical";
import styles from "./styles/style.module.css";
export type MessageTypes = "" | "alert" | "warning";
type SerializedMessageContentNode = Spread<
  { messageType: MessageTypes },
  SerializedElementNode
>;
export class MessageContentNode extends ElementNode {
  _messageType: MessageTypes;
  static getType(): string {
    return "message-content";
  }
  static clone(node: MessageContentNode): MessageContentNode {
    return new MessageContentNode(node._messageType);
  }
  constructor(messageType?: MessageTypes, key?: string) {
    super(key);
    this._messageType = messageType ?? "";
  }
  createDOM(config: EditorConfig): HTMLElement {
    const dom = document.createElement("aside");
    dom.classList.add(styles.Message__content);
    if (this.getMessageType() === "alert") {
      dom.classList.add(styles.Message__content_alert);
    }
    if (this.getMessageType() === "warning") {
      dom.classList.add(styles.Message__content_warning);
    }
    return dom;
  }
  updateDOM(): boolean {
    return false;
  }
  exportDOM(): DOMExportOutput {
    const element = document.createElement("div");
    element.classList.add(styles.Message__content);
    element.setAttribute("data-lexical-message-content", "true");
    return { element };
  }
  static importJSON(
    serializedNode: SerializedMessageContentNode
  ): MessageContentNode {
    return $createMessageContentNode(serializedNode.messageType);
  }
  exportJSON(): SerializedMessageContentNode {
    return {
      ...super.exportJSON(),
      messageType: this.getMessageType(),
      type: "message-content",
      version: 1,
    };
  }
  getMessageType() {
    return this._messageType;
  }
  // æ”¹è¡Œã™ã‚‹æ™‚ã®æŒ™å‹•ã‚’åˆ¶å¾¡
  insertNewAfter(
    selection: RangeSelection,
    restoreSelection = true
  ): null | ParagraphNode | MessageContentNode {
    const children = this.getChildren();
    const childrenLength = children.length;
    // å¾Œã‚è¡ŒäºŒã¤ãŒç©ºã«ç¶šã„ã¦ã„ã‚‹çŠ¶æ…‹ã§æ”¹è¡Œã‚’ã—ãŸæ™‚ã®æŒ™å‹•ã‚’åˆ¶å¾¡
    // Messageãƒãƒ¼ãƒ‰ã‚’è§£é™¤ã—ã¦ã€æ–°è¦ã®Paragraphãƒãƒ¼ãƒ‰ã‚’æŒ¿å…¥ã—ã¦ã„ã‚‹
    if (
      childrenLength >= 2 &&
      children[childrenLength - 1].getTextContent() === "\n" &&
      children[childrenLength - 2].getTextContent() === "\n" &&
      selection.isCollapsed() &&
      selection.anchor.key === this.__key &&
      selection.anchor.offset === childrenLength
    ) {
      children[childrenLength - 1].remove();
      children[childrenLength - 2].remove();
      const newElement = $createParagraphNode();
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    const { anchor, focus } = selection;
    const firstPoint = anchor.isBefore(focus) ? anchor : focus;
    const firstSelectionNode = firstPoint.getNode();
    // æ–‡å­—åˆ—ãŒå­˜åœ¨ã™ã‚‹æ™‚ã®Enterã®æŒ™å‹•
    if ($isTextNode(firstSelectionNode)) {
      let node = firstSelectionNode;
      const insertNodes = [];
      while (true) {
        if ($isTextNode(node)) {
          insertNodes.push($createTextNode());
          const nextNode = node.getNextSibling<TextNode>();
          if (!nextNode) {
            break;
          }
          node = nextNode;
        } else {
          break;
        }
      }
      const split = firstSelectionNode.splitText(anchor.offset)[0];
      const x = anchor.offset === 0 ? 0 : 1;
      const index = split.getIndexWithinParent() + x;
      const codeNode = firstSelectionNode.getParentOrThrow();
      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];
      codeNode.splice(index, 0, nodesToInsert);
      // ã‚­ãƒ£ãƒ¡ãƒ«ã‚’æ”¹è¡Œå¾Œã®è¡Œã«ç§»è¡Œã™ã‚‹
      const last = insertNodes[insertNodes.length - 1];
      if (last) {
        last.select();
      } else if (anchor.offset === 0) {
        split.selectPrevious();
      } else {
        split.getNextSibling()!.selectNext(0, 0);
      }
    }
    // æ–‡å­—åˆ—ãŒãªã„è¡Œã§ã®æ”¹è¡Œã—ãŸæ™‚ã®æŒ™å‹•ã‚’åˆ¶å¾¡
    if ($isMessageContentNode(firstSelectionNode)) {
      const { offset } = selection.anchor;
      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);
      firstSelectionNode.select(offset + 1, offset + 1);
    }
    return null;
  }
}
export function $createMessageContentNode(
  messageType?: MessageTypes
): MessageContentNode {
  return $applyNodeReplacement(new MessageContentNode(messageType));
}
export function $isMessageContentNode(
  node: LexicalNode | null | undefined
): node is MessageContentNode {
  return node instanceof MessageContentNode;
}
```

åŸºæœ¬çš„ã«ç‹¬è‡ªã® Node ã‚’ä½œã‚‹å ´åˆã¯ã€[ElementNode](https://lexical.dev/docs/api/classes/lexical.ElementNode)ãƒ»[DecoratorNode](https://lexical.dev/docs/api/classes/lexical.DecoratorNode)ãƒ»[DecoratorBlockNode](https://lexical.dev/docs/api/classes/lexical_react_LexicalDecoratorBlockNode.DecoratorBlockNode)ã‚’ç¶™æ‰¿ã—ã€ç‹¬è‡ªã®å®šç¾©ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
ã©ã® Node ã‚’ç¶™æ‰¿ã™ã‚‹ã‹ã¯è‡ªåˆ†ã®ä¸­ã§ãƒãƒƒã‚­ãƒªã¨ä½¿ã„åˆ†ã‘ã¯ã§ãã¦ã„ãªã„ã®ã§ã™ãŒã€è¦ç´ ã¨ã—ã¦ã¯å˜ç´”ãª Node ã ãŒå„æ“ä½œã«å¯¾ã—ã¦ã®å‡¦ç†ã‚’è¨˜è¼‰ã—ãŸã„å ´åˆã¯ ElementNode ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ä¸€æ–¹ã§ã€DecoratorNode ã‚„ DecoratorBloackNode ã¯ç”»é¢ã«è¡¨ç¤ºã•ã›ãŸã„è¦ç´ ãŒã‹ãªã‚Šè¤‡é›‘ã§ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’è¡¨ç¤ºã•ã›ã‚‹ã‚ˆã†ã«ã—ãŸã„å ´åˆã«ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ã¾ã‚ã€ãã“ã¾ã§å³å¯†ã«ã¯ä½¿ã„åˆ†ã‘ã¯ã§ãã¦ã„ãªã„ã§ã™ã€‚
Node ã®å®šç¾©ãŒã§ããŸã‚‰ã€ãã® Node ã‚’ä½œæˆã™ã‚‹é–¢æ•°ã¨ã€ã‚¬ãƒ¼ãƒ‰é–¢æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚
åŸºæœ¬çš„ã«è‡ªåˆ†ç‹¬è‡ªã® Node ã‚’å®šç¾©ã™ã‚‹æ™‚ã¯ã€Node ã‚¯ãƒ©ã‚¹ã®å®šç¾©ã€Node ã‚’ä½œæˆã™ã‚‹é–¢æ•°ã€ã‚¬ãƒ¼ãƒ‰é–¢æ•°ã‚’ã‚»ãƒƒãƒˆã§ä½œã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚
Node ä½œæˆé–¢æ•°ã¨ã‚¬ãƒ¼ãƒ‰é–¢æ•°ã¯è¦‹ãŸã‚‰åˆ†ã‹ã‚‹ã¨æ€ã†ã®ã§ã€çœç•¥ã—ã¾ã™ã€‚
Node ä½œæˆéƒ¨åˆ†ã«ã¤ã„ã¦ã¯ãŠä½œæ³•çš„ãªã¨ã“ã‚ã ã‘è»½ãè§¦ã‚Œã¾ã™ã€‚
ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç‹¬è‡ª Node ã‚’ä½œæˆã™ã‚‹æ™‚ã¯å®šç¾©ã—ã¾ã™ã€‚

```tsx
    static getType(){}
    static clone(node) {}
    createDOM() {}
    updateDOM(): boolean {}
    exportDOM(): DOMExportOutput {}
    static importJSON(serializedNode) {}
    exportJSON(){}
```

å„å½¹å‰²ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

1. static getType()
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ãƒ‰ã®å‹ã‚’æ–‡å­—åˆ—ã§è¿”ã—ã¾ã™ã€‚ã“ã®å‹ã¯ã€ã‚¨ãƒ‡ã‚£ã‚¿å†…ã§ãƒãƒ¼ãƒ‰ã‚’ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚Lexical ã¯ã€ã“ã®å‹ã‚’ä½¿ç”¨ã—ã¦ãƒãƒ¼ãƒ‰ã®ä½œæˆã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚’è¡Œã„ã¾ã™ã€‚getType()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¯ãƒ©ã‚¹ã®é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã€ãƒãƒ¼ãƒ‰ã®å‹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
2. static clone(node)
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ—¢å­˜ã®ãƒãƒ¼ãƒ‰ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚ãƒãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚clone()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…ƒã®ãƒãƒ¼ãƒ‰ã¨åŒã˜å‹ã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å¤‰æ›´ã›ãšã«ã€ãƒãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
3. createDOM()
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã«å¯¾å¿œã™ã‚‹ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚Lexical ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã€ã‚¨ãƒ‡ã‚£ã‚¿å†…ã§ãƒãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã® DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚createDOM()ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€ãƒãƒ¼ãƒ‰ã®ç¨®é¡ã«å¿œã˜ã¦é©åˆ‡ãª DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã€å¿…è¦ãªã‚¯ãƒ©ã‚¹åã‚„ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚
4. updateDOM(): boolean
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã®çŠ¶æ…‹ãŒå¤‰æ›´ã•ã‚ŒãŸéš›ã«ã€å¯¾å¿œã™ã‚‹ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚updateDOM()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã®ç¾åœ¨ã®çŠ¶æ…‹ã¨ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã®çŠ¶æ…‹ã‚’æ¯”è¼ƒã—ã€å¿…è¦ã«å¿œã˜ã¦ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¤‰æ›´ãŒè¡Œã‚ã‚ŒãŸå ´åˆã¯ true ã‚’ã€å¤‰æ›´ãŒä¸è¦ãªå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚
5. exportDOM(): DOMExportOutput
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã«å¤‰æ›ã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚exportDOM()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã®ç¾åœ¨ã®çŠ¶æ…‹ã‚’è¡¨ã™ DOM ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã€ãã®ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã‚’ HTML å½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
6. static importJSON(serializedNode)
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸãƒãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆJSON å½¢å¼ï¼‰ã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ãƒ‰ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚importJSON()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’å…ƒã«æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¨ãƒ‡ã‚£ã‚¿ã®çŠ¶æ…‹ã‚’å¾©å…ƒã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
7. exportJSON()
   ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ãƒ‰ã‚’ JSON å½¢å¼ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚exportJSON()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒãƒ¼ãƒ‰ã®ç¾åœ¨ã®çŠ¶æ…‹ã‚’è¡¨ã™ JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã® JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ãƒãƒ¼ãƒ‰ã®å‹ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãªã©ã®æƒ…å ±ãŒå«ã¾ã‚Œã¾ã™ã€‚exportJSON()ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¨ãƒ‡ã‚£ã‚¿ã®çŠ¶æ…‹ã‚’ä¿å­˜ã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

æ–‡å­—ã ã‘ã§è¦‹ã‚‹ã¨ä½•ã®ã“ã£ã¡ã‚ƒã¨ã„ã†æ„Ÿã˜ã§ã™ãŒã€å®Ÿéš›ã«é–‹ç™ºã—ã¦ã¿ã¦ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã¨ã‚„ã£ã¦ã„ãã¨ã€ãªã‚“ã¨ãªãã‚¤ãƒ¡ãƒ¼ã‚¸ãŒã¤ã‹ã‚ã¾ã™ã€‚
ã“ã‚Œã‚‰ãŒä½œæˆã§ããŸã‚‰ã€ä½¿ç”¨ã™ã‚‹ Node ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¦ã€

```tsx
export const nodes: Klass<LexicalNode>[] = [
  MessageContentNode,
  ...ãã®ä»–ã®Node,
];
```

Plugin ã‚’ Lexical ã®åˆæœŸè¨­å®šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä¸­ã«è¨˜è¼‰ã—ã¾ã™ã€‚

```tsx
<LexicalComposer initialConfig={initialConfig}>
  è‰²ã€…ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯çœç•¥
  <MessagePlugin></MessagePlugin>
</LexicalComposer>
```

åŸºæœ¬çš„ãªæµã‚Œã¯ä¸Šè¨˜ã®é€šã‚Šã§ã™ã€‚

## ã‚³ãƒ”ãƒšã«ã‚ˆã‚‹ãƒªãƒ³ã‚¯å¤‰æ›ã‹ã‚‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚«ãƒ¼ãƒ‰ã¾ã§ã®å®Ÿè£…

[ã“ã¡ã‚‰ã®è¨˜äº‹](https://zenn.dev/mktu/articles/6ff46411458823)ã‚’å¤§ã„ã«å‚è€ƒï¼ˆã‹ãªã‚Šã‚’ä¸¸ãƒ‘ã‚¯ãƒªï¼‰ã—ã¦ã„ã¾ã™ã®ã§ã€è©³ç´°ã¯è¨˜è¼‰ã—ã¾ã›ã‚“ã€‚

## ç”»åƒã®è²¼ã‚Šä»˜ã‘

ã“ã“ã‚‚[ã“ã¡ã‚‰ã®è¨˜äº‹](https://zenn.dev/mktu/articles/7d547829f330c9)ã‚’å¤§ã„ã«å‚è€ƒï¼ˆã‹ãªã‚Šã‚’ä¸¸ãƒ‘ã‚¯ãƒªï¼‰ã—ã¦ã„ã¾ã™ã®ã§ã€è©³ç´°ã¯è¨˜è¼‰ã—ã¾ã›ã‚“ã€‚

## ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã‚’ HTML ã«å¤‰æ›ã™ã‚‹

Markdown å¤‰æ›ã™ã‚‹å‡¦ç†ã«ã¤ã„ã¦ã¯ä¸»ã«ã“ã®æ©Ÿèƒ½ã‚’é”æˆã™ã‚‹ãŸã‚ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```tsx
"use client";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { $convertToMarkdownString } from "@lexical/markdown";
import { convertHtml } from "@/app/actions";
import { TRANSFORMER_PATTERNS } from "./MarkdownPlugin";
import PrimaryButton from "../../button/PrimaryButton";
import { useState } from "react";
export default function GenerateHtmlPlugin() {
  const [editor] = useLexicalComposerContext();
  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°åˆ¶å¾¡ç”¨ã®State
  const [isLoading, setIsLoading] = useState(false);
  // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«å®Ÿè¡Œ
  const generateHtml = async () => {
    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’é–‹å§‹
    setIsLoading(() => true);
    // Lexicalã®Editor Statesã‚’æ›´æ–°ã™ã‚‹
    editor.update(async () => {
      // å¤‰æ›ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åˆã‚ã›ã¦Editor Statesã‚’Markdownã«å¤‰æ›ã™ã‚‹å‡¦ç†
      const markdown = $convertToMarkdownString(TRANSFORMER_PATTERNS);
      // ã‚µãƒ¼ãƒãƒ¼å´ã§å‹•ãconvertHtmlé–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹
      convertHtml(markdown)
        .then(async (res) => {
          // ã‚¯ãƒªãƒƒã‚¯ãƒœãƒ¼ãƒ‰ã«HTMLã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼
          await global.navigator.clipboard.writeText(res);
          alert("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ä¿å­˜ã—ã¾ã—ãŸ");
        })
        .catch((e) => Promise.reject(e))
        .finally(() => {
          setIsLoading(() => false);
        });
    });
  };
  // HTMLä½œæˆç”¨ãƒœã‚¿ãƒ³
  return (
    <PrimaryButton onClick={generateHtml}>
      {isLoading ? "...å®Ÿè¡Œä¸­" : "ãƒ–ãƒ­ã‚°ç”¨ã«HTMLç”Ÿæˆ"}
    </PrimaryButton>
  );
}
```

ã“ã“ã§æ³¨ç›®ã™ã‚‹ã®ã¯`$convertToMarkdownString`é–¢æ•°ã ã‘ã§ã™ã€‚
å¾Œã¯ã‚ã¾ã‚Š Lexical ã¨å¤§ããé–¢ä¿‚ãªã„ã§ã™ã€‚
`$convertToMarkdownString`é–¢æ•°ã§ã™ãŒã€å¼•æ•°ã« ElementTransformer ã‚„ TextMatchTransformer ã‚’æ¸¡ã™ã“ã¨ã§ã€äºˆã‚ export ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§å®šç¾©ã—ãŸå†…å®¹ã‚’å®Ÿè¡Œã—ã¦ãã‚Œã¾ã™ã€‚
ãã—ã¦ã€å¤‰æ›å‡¦ç†ãŒçµ‚ã‚ã£ãŸå¾Œã® Markdown ã‚’è¿”ã—ã¦ãã‚Œã¾ã™ã€‚
convertHtml é–¢æ•°ã®å‡¦ç†ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```tsx
export async function convertHtml(markdown: string, isBlog: boolean = true) {
  const pickNoSrcImgPattern = /<img(?=\s+alt)(?![\s>]*src)[\s\S]*? \/>/gi;
  const pickBase64SourcePattern = /\(data:image\/[a-zA-Z0-9\+\/,;\=]+\)/gi;
  const pickBase64Source = markdown.match(pickBase64SourcePattern);
  const normalMessagePattern =
    /:::message(?!\s+(?:warning|alert))\s*([\s\S]*?)\s*:::/g;
  const normalMessageKey = "----normal----";
  const normalMessages = markdown.match(normalMessagePattern);
  let convertMarkDown = markdown
    .replaceAll(normalMessagePattern, normalMessageKey)
    .replaceAll(":::message warning", ":::message ");
  const linkCardPattern = /@(?:\[linkCard\])(?:\(([^(]+)\))/gi;
  const matchLinkCards = markdown.match(linkCardPattern);
  const urls: string[] = [];
  matchLinkCards?.forEach((val) => {
    convertMarkDown = convertMarkDown.replace(val, `----focusUrl----`);
    urls.push(val.replace(/@\[linkCard\]\(/gi, "").replace(/\)$/, ""));
  });
  const tweetPattern =
    /----tweetEmbed----\(https?:\/\/(?:www\.)?(twitter|x)\.com\/(?:#!\/)?(?:\w+)\/status(?:es)?\/(\d+)\)/gi;
  const matchTweets = convertMarkDown.match(tweetPattern);
  const matchTweetIds = matchTweets?.map((t) =>
    t
      .replace(
        /----tweetEmbed----\(https?:\/\/(?:www\.)?(twitter|x)\.com\/(?:#!\/)?(?:\w+)\/status(?:es)?\//,
        ""
      )
      .replace(")", "")
  );
  convertMarkDown = convertMarkDown.replaceAll(
    /----tweetEmbed----\(https?:\/\/(?:www\.)?(twitter|x)\.com\/(?:#!\/)?(?:\w+)\/status(?:es)?\//gi,
    "----tweetEmbed----"
  );
  let contentHtml = markdownToHtml(
    isBlog ? addNewLinesInCode(convertMarkDown) : convertMarkDown
  );
  urls.forEach((val) => {
    contentHtml = contentHtml.replace(
      "<p>----focusUrl----</p>",
      `<p><iframe class="hatenablogcard" style="width: 100%;height: 155px;max-width: 680px;border-style:none;"src="https://hatenablog-parts.com/embed?url=${val}"></iframe></p>`
    );
  });
  normalMessages?.forEach((val) => {
    const insertText = val
      .replace(":::message \n", "")
      .replace("\n:::", "")
      .replaceAll("\n", "<br />");
    contentHtml = contentHtml.replace(
      `<p>${normalMessageKey}</p>`,
      `<aside class="msg normal"><span class="msg-symbol">!</span><div class="msg-content"><p>${insertText}</p></aside>`
    );
  });
  const pickNoSrcImg = contentHtml.match(pickNoSrcImgPattern);
  pickBase64Source?.forEach((val, index) => {
    if (pickNoSrcImg) {
      contentHtml = contentHtml.replace(
        pickNoSrcImg[index],
        `${pickNoSrcImg[index].replace("/>", "")} src="${val.replace(
          /\(|\)/gi,
          ""
        )}" >`
      );
    }
  });
  matchTweetIds?.forEach((val, index) => {
    if (!matchTweets) {
      return;
    }
    const matchTweetUrl = matchTweets[index]
      .replace("----tweetEmbed----(", "")
      .replace(/\)$/gi, "");
    contentHtml = contentHtml.replace(
      `<p>----tweetEmbed----${val})</p>`,
      `<div class="twitter-tweet twitter-tweet-rendered"
        style="display: flex; max-width: 550px; width: 100%; margin-top: 10px; margin-bottom: 10px;position:relative;height: 300px;overflow-y:hidden;">
        <a href="${matchTweetUrl}"
        onMouseOut="this.style.opacity='0.8';" onMouseOver="this.style.opacity='0.6'"
        target="_blank" rel="noopener noreferrer"
            style="position: absolute;bottom: 0;width: 100%;height: 100px;background-color: #fff;opacity: 0.8;display: flex;align-items: center;justify-content: center;">
            è©³ç´°ã‚’ç¢ºèªã™ã‚‹
        </a>
        <iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true"
            class="tweet-iframe"
            style="position: static; visibility: visible; width: 550px; height: 400%; display: block; flex-grow: 1;pointer-events: none;"
            title="X Post"
            src="https://platform.twitter.com/embed/Tweet.html?dnt=false&amp;embedId=twitter-widget-0&amp;features=e30%3D&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=${val}&amp;lang=en&amp;origin=file%3A%2F%2Fwsl%24%2FUbuntu%2Fvar%2Fwww%2Fdocument-blog%2Ftest.html&amp;theme=light&amp;widgetsVersion=2615f7e52b7e0%3A1702314776716&amp;width=550px"
            data-tweet-id="${val}"></iframe>
    </div>`
    );
  });
  contentHtml = contentHtml.replaceAll(
    '<p><span class="embed-block embed-youtube">',
    '<p class="youtube-embed-warpper"><span class="embed-block embed-youtube">'
  );
  const html = `<style>${css}</style><div class='znc'>${contentHtml.replaceAll(
    replaceWord,
    "<br />"
  )}</div>`;
  return html;
}
const css = `@import url(https://fonts.googleapis.com/css?family=Noto+Sans+JP);p{margin-top:0;margin-bottom:0}h3{margin-top:0;margin-bottom:0}.znc{line-height:1.5;font-family:'Noto Sans JP',sans-serif!important}.znc>*:first-child{margin-top:0}.znc i,.znc cite,.znc em{font-style:italic}.znc strong{font-weight:700}.znc a{color:#0f83fd}.znc a:hover{text-decoration:underline}.znc ul,.znc ol{margin:.75rem 0;line-height:1.7}.znc ul>li,.znc ol>li{margin:.4rem 0}.znc ul ul,.znc ul ol,.znc ol ul,.znc ol ol{margin:.2em 0}.znc ul p,.znc ol p{margin:0}.znc ul{padding-left:1.8em}.znc ul>li{list-style:disc}.znc ul>li::marker{font-size:1.1em;color:#65717b}.znc ol{padding-left:1.7em}.znc ol>li{list-style:decimal;padding-left:.2em}.znc ol>li::marker{color:#65717b;font-weight:600;letter-spacing:-.05em}.znc .contains-task-list .task-list-item{list-style:none}.znc .task-list-item-checkbox{margin-left:-1.5em;font-size:1em;pointer-events:none}.znc h1{padding-bottom:.2em;font-size:1.7em;border-bottom:solid 1px #d6e3ed}.znc h2{padding-bottom:.3em;font-size:1.5em;border-bottom:solid 1px #d6e3ed}.znc h3{font-size:1.3em}.znc h4{font-size:1.1em}.znc h5{font-size:1em}.znc h6{font-size:.9em}@media screen and (max-width:576px){.znc h1{font-size:1.6em}.znc h2{font-size:1.4em}.znc h3{font-size:1.2em}.znc h4{font-size:1.1em}.znc h5{font-size:1em}.znc h6{font-size:.85em}}.znc hr{border-top:2px solid #d6e3ed;margin:2.5rem 0}.znc blockquote{font-size:.97em;margin:1.4rem 0;border-left:solid 3px #8f9faa;padding:2px 0 2px .7em;color:#65717b}.znc blockquote p{margin:1rem 0}.znc blockquote>:first-child{margin-top:0}.znc blockquote>:last-child{margin-bottom:0}.znc blockquote.twitter-tweet{display:none}.znc table{margin:.5rem auto;width:auto;border-collapse:collapse;font-size:.95em;line-height:1.5;word-break:normal;display:block;overflow:auto;-webkit-overflow-scrolling:touch}.znc th,.znc td{padding:.5rem;border:solid 1px #d6e3ed;background:#fff}.znc th{font-weight:700;background:#edf2f7}.znc code{padding:.2em .4em;background:rgba(33,90,160,.07);font-size:.85em;border-radius:4px;vertical-align:.08em}.znc code,.znc .code-block-filename{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,monospace,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";-webkit-font-smoothing:antialiased}.znc pre{margin:1.3rem 0;background:#1a2638;overflow-x:auto;-webkit-overflow-scrolling:touch;border-radius:4px;word-break:normal;word-wrap:normal;display:flex}.znc pre:after{content:"";width:8px;flex-shrink:0}.znc pre code{margin:0;padding:0;background:rgba(0,0,0,0);font-size:.9em;color:#fff}.znc pre>code{display:block;padding:1.1rem}@media screen and (max-width:576px){.znc pre>code{padding:1rem .8rem;font-size:.85em}}.znc .code-block-container{position:relative;margin:1.3rem 0}.znc .code-block-container pre{margin:0}.znc .code-block-filename{display:table;max-width:100%;background:#323e52;color:rgba(255,255,255,.9);font-size:12px;line-height:1.3;border-radius:4px 4px 0 0;padding:6px 12px 20px;margin-bottom:-16px}.znc .code-block-filename-container+pre{border-top-left-radius:0}.znc img:not(.emoji){display:table;max-width:100%;height:auto}.znc img+br{display:none}.znc img~em{display:block;margin:-1rem auto 0;line-height:1.3;text-align:center;color:#65717b;font-size:.92em}.znc a:has(img){display:table;margin:0 auto}.znc details{font-size:.95em;margin:1rem 0;line-height:1.7}.znc summary{cursor:pointer;outline:0;padding:.7em .7em .7em .9em;border:solid 1px #d6e3ed;color:var(--c-contrast);font-size:.9em;border-radius:14px;background:#fff}.znc summary::-webkit-details-marker{color:#65717b}.znc details[open]>summary{border-radius:14px 14px 0 0;box-shadow:none;background:#f1f5f9;border-bottom:none}.znc .details-content{padding:.5em .9em;border:solid 1px #d6e3ed;border-radius:0 0 14px 14px;background:#fff}.znc .details-content>*{margin:.5em 0}.znc span.embed-block{display:block;width:100%;margin:1.5rem 0}.znc .embed-slideshare,.znc .embed-speakerdeck,.znc .embed-codepen,.znc .embed-jsfiddle,.znc .embed-youtube,.znc .embed-stackblitz{padding-bottom:calc(56.25% + 38px);position:relative;width:100%;height:0}.znc .embed-slideshare iframe,.znc .embed-speakerdeck iframe,.znc .embed-codepen iframe,.znc .embed-jsfiddle iframe,.znc .embed-youtube iframe,.znc .embed-stackblitz iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.znc .embed-slideshare iframe{border:1px solid #d6e3ed}.znc .embed-jsfiddle iframe{border:1px solid #d6e3ed}.znc .embed-figma{border:1px solid #d6e3ed}.znc .zenn-embedded iframe{width:100%;display:block}.znc .zenn-embedded-link-card{margin:1rem auto}.znc .zenn-embedded-link-card iframe{height:125px}.znc .zenn-embedded-tweet,.znc .zenn-embedded-mermaid,.znc .zenn-embedded-github,.znc .zenn-embedded-gist{margin:1.5rem auto}.znc embed-katex:not([display-mode="1"]){display:inline-flex;overflow-x:auto;max-width:100%;-ms-overflow-style:none;scrollbar-width:none}.znc embed-katex:not([display-mode="1"])::-webkit-scrollbar{display:none}.znc embed-katex[display-mode="1"]{display:block;width:100%;overflow-x:auto}.znc pre[class*=language-]{position:relative}.znc .token.namespace{opacity:.7}.znc .token.comment,.znc .token.prolog,.znc .token.doctype,.znc .token.cdata{color:#94a1b3}.znc .token.operator,.znc .token.boolean,.znc .token.number{color:#ffc56d}.znc .token.attr-name,.znc .token.string{color:#ffc56d}.znc .token.entity,.znc .token.url,.znc .language-css .token.string,.znc .style .token.string{color:#ffc56d}.znc .token.selector{color:#ff8fa3}.znc .token.atrule,.znc .token.attr-value,.znc .token.keyword,.znc .token.important{color:#ff8fa3}.znc .token.deleted{color:#ff8fa3}.znc .token.inserted{color:#b4ff9b}.znc .token.deleted:not(.prefix){background:rgba(218,54,50,.2);color:inherit;display:block}.znc .token.prefix{user-select:none}.znc .token.inserted:not(.prefix){background:rgba(0,146,27,.2);color:inherit;display:block}.znc .token.coord{color:#aad4ff}.znc .token.regex,.znc .token.statement{color:#ffc56d}.znc .token.placeholder,.znc .token.variable{color:#fff}.znc .token.important,.znc .token.statement,.znc .token.bold{font-weight:700}.znc .token.punctuation{color:#939bc1}.znc .token.entity{cursor:help}.znc .token.italic{font-style:italic}.znc .token.tag,.znc .token.property,.znc .token.function{color:#38c7ff}.znc .token.attr-name{color:#ff8fa3}.znc .token.attr-value{color:#ffc56d}.znc .token.style,.znc .token.script{color:#ffc56d}.znc .token.script .token.keyword{color:#ffc56d}.znc aside.msg{display:flex;align-items:flex-start;margin:.5rem 0;padding:.75em 1em;border-radius:4px;background:#fff6e4;color:rgba(0,0,0,.7);font-size:.94em;line-height:1.6}.znc aside.msg.alert{background:#ffeff2}.znc aside.msg.normal{background:#e9f2ff}.znc aside.msg a{color:inherit;text-decoration:underline}.znc .msg-symbol{display:flex;align-items:center;justify-content:center;font-weight:700;width:1.4rem;height:1.4rem;border-radius:99rem;background-color:#ffb84c;color:#fff}.znc aside.msg.alert .msg-symbol{background-color:#ff7670}.znc aside.msg.normal .msg-symbol{background-color:#1d7afc}.znc .msg-content{flex:1;margin-left:.6em;min-width:0}.znc .msg-content>*{margin:.7rem 0}.znc .msg-content>*:first-child{margin-top:0}.znc .msg-content>*:last-child{margin-bottom:0}.znc .footnotes{margin-top:3rem;color:#65717b;font-size:.9em}.znc .footnotes li::marker{color:#65717b}.znc .footnotes-title{padding-bottom:3px;border-bottom:solid 1px #65717b;font-weight:700;font-size:15px}.znc .footnotes-list{margin:13px 0 0}.znc .footnote-item:target{background:#f1f5f9}.twitter-tweet>a{position:absolute;bottom:0;width:100%;height:100px;background-color:#fff;opacity:.8;display:flex;align-items:center;justify-content:center}.twitter-tweet>a:hover{opacity:.6}.youtube-embed-warpper{max-width:550px}.embed-figma{max-width:550px}`;
```

è‰²ã€…åˆ†ã‹ã‚Šã¥ã‚‰ã„ã‚³ãƒ¼ãƒ‰ã§ã™ãŒã€ã¨ã‚Šã‚ãˆãšä»¥ä¸‹ã®ã“ã¨ã‚’ã‚„ã£ã¦ã„ã¾ã™ã€‚
â‘ [zenn-editor](https://github.com/zenn-dev/zenn-editor)ã® zenn-markdown-html ã§ HTML å¤‰æ›ã‚’ã—ã¦ã„ã‚‹
â‘¡ ä¸Šè¨˜è³„ãˆãªã„éƒ¨åˆ†ã‚’ç‹¬è‡ªã§æ­£è¦è¡¨ç¾ãªã©ã‚’ä½¿ã„ HTML å¤‰æ›ã—ã¦ã„ã‚‹
â‘¢[zenn-content-css](https://github.com/zenn-dev/zenn-editor/tree/canary/packages/zenn-content-css)ã‚’ä¸€éƒ¨æ”¹å¤‰ã—ãŸã‚‚ã®ã¨ç”Ÿæˆã—ãŸ HTML ã‚³ãƒ¼ãƒ‰ã‚’ãã£ã¤ã‘ã¦è¿”ã™
ã¡ã‚‡ã£ã¨å‘¨ã‚Šãã©ã„ã®ã¨ã€Lexical ã«ã¯ HTML ã‚³ãƒ¼ãƒ‰ã¸ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã€‚
ã§ã¯ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚Œã°è‰¯ã„ã¨æ€ã†ã®ã¯å½“ç„¶ã®ã“ã¨ã§ã™ãŒã€ç‰¹ã«ç‹¬è‡ªã§ä½œã£ãŸ Node ã¯è‡ªåˆ†ã§ HTML å¤‰æ›ã™ã‚‹éš›ã®è¦ç´ ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã¡ã‚‡ã£ã¨ãã‚Œã‚’é¢å€’ã«æ€ã£ãŸã®ã¨ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã„ã„æ„Ÿã˜ã«ã™ã‚‹ã“ã¨ãŒã§ããªã‹ã£ãŸãŸã‚ã€Zenn ã®åŠ›ã‚’å€Ÿã‚Šã¦ã„ã¾ã™ã€‚
å°†æ¥çš„ã«ã¯ Tailwind CSS ã‚‚ä½¿ã„ã¤ã¤ã€è‡ªå‰ã§è³„ãˆã‚‹ã‚ˆã†ã«ã—ã¦ã„ããŸã„ã§ã™ã€‚

## æ—¢å­˜ã® Editor States ã‚’åæ˜ ã™ã‚‹

Lexical ã¯ä¸€åº¦ Editor States ã‚’è¨­å®šã—ãŸã‚‰ update ãƒ¡ã‚½ãƒƒãƒ‰ã‚’çµŒç”±ã—ãªã„ã¨åŸºæœ¬çš„ã«ã¯å€¤ã‚’å¤‰æ›´ã¯ã§ãã¾ã›ã‚“ã€‚
ã§ã™ãŒã€ç‰¹å®šã®å€¤ã§ã¯ãªã Editor States ãã®ã‚‚ã®ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚
ãã®ç‰¹æ€§ã‚’æ´»ã‹ã—ã€ç·¨é›†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸæ™‚ä»¥å‰ã®å†…å®¹ã‚’åæ˜ ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚
å…·ä½“çš„ãªå®Ÿè£…ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```tsx
import { getBlogJsonByPublicDir } from "@/app/actions";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { useEffect } from "react";
export const ImportPlugin = ({ postId }: { postId: string }) => {
  const [editor] = useLexicalComposerContext();
  useEffect(() => {
    getBlogJsonByPublicDir(postId)
      .then((res) => {
        const editorState = editor.parseEditorState(res ?? "");
        editor.setEditorState(editorState);
      })
      .catch(() => {
        alert("ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒã§ãã¾ã›ã‚“ã§ã—ãŸ");
      });
  }, []);
  return null;
};
export default ImportPlugin;
```

React ãƒ™ãƒ¼ã‚¹ã§é–‹ç™ºã—ã¦ã„ã‚‹ã¨ã€LexicalComposer ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§å›²ã‚€å¿…è¦ãŒã‚ã‚‹ã®ã§ã€null ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚
ã¾ãŸã€getBlogJsonByPublicDir é–¢æ•°ã¯ ID ã‚’ã‚‚ã¨ã« JSON ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã€ãã‚Œã‚’ JSON.stringfy ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚
parseEditorState ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–‡å­—åˆ—ã‚’ Lexical ã® Editor States ã«å¤‰æ›ã—ã¾ã™ã€‚
æœ€å¾Œã« setEditorState ãƒ¡ã‚½ãƒƒãƒ‰ã§ä»Šé–‹ã„ã¦ã„ã‚‹ç”»é¢ã® Editor States ã‚’ getBlogJsonByPublicDir é–¢æ•°ã§å–å¾—ã—ãŸã‚‚ã®ã«ç½®ãæ›ãˆã¾ã™ã€‚
Editor States ã¯ JSON å½¢å¼ã§ä¿å­˜ã§ãã‚‹ãŸã‚ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã« JSON æ–‡å­—åˆ—ã‚’ãã®ã¾ã¾ä¿å­˜ã‚‚ã§ãã¾ã™ã—ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã« JSON ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ãã®ãŸã‚ã€è¦ä»¶ã«åˆã‚ã›ãŸä¿å­˜æ–¹æ³•ã‚’é¸æŠã§ãã‚‹ã®ã¯å¼·ã¿ã‹ãªã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚

## è‡ªå‹•ã§ä¿å­˜ã™ã‚‹ã—ãã¿ã‚’ä½œæˆ

å‰ã¾ã§ã¯æ›¸ã„ãŸã‚‰ Ctr + s ã§ä¿å­˜ã¨ã„ã†ã“ã¨ã‚’ã‚ˆãã‚„ã£ã¦ã„ãŸã¨æ€ã„ã¾ã™ã€‚
ä»Šã‚‚ã‚‚ã¡ã‚ã‚“ãã®ä½œæ¥­ãŒå®Œå…¨ã«ãªããªã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã§ã™ãŒã€å¤§åˆ†æ¸›ã£ãŸã¨æ€ã„ã¾ã™ã€‚
Notion ã‚„ Google ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãªã©ã¯æ›¸ã„ã¦ã„ã‚‹å†…å®¹ã‚’è‡ªå‹•ã§ä¿å­˜ã—ã¦ãã‚Œã‚‹ãŸã‚ã§ã™ã€‚
ã¨ãªã‚‹ã¨éƒ½åº¦ä¿å­˜ãƒœã‚¿ãƒ³ã‚’æŠ¼ã•ãªã„ã¨ã„ã‘ãªã„ã®ã¯ã€ä»Šã ã¨é¢å€’ã«ãªã‚‹ã¨æ€ã„è‡ªå‹•ã§ä¿å­˜ã™ã‚‹æ©Ÿèƒ½ã‚’æ­è¼‰ã—ã¾ã—ãŸã€‚
å®Ÿè£…ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```tsx
"use client";
import { storeContent } from "@/app/actions";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { $getRoot, EditorState } from "lexical";
import { useEffect, useRef } from "react";
let isFirst = true;
const AutoSavePlugin = ({ postId }: { postId: string }) => {
  const [editor] = useLexicalComposerContext();
  // settimeouté–¢æ•°ã‚’æ ¼ç´ã™ã‚‹
  const timer = useRef<NodeJS.Timeout | null>(null);
  useEffect(() => {
    // Editor StatesãŒæ›´æ–°ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å‡¦ç†ãŒèµ°ã‚‹ã‚ˆã†ã«ç™»éŒ²ã—ã¦ãŠã
    return editor.registerUpdateListener(({ editorState }) => {
      /**
       * æœ€æ–°ã®Editor Stateã§å‡¦ç†ã‚’è¡Œã†
       * Editor Statesã¯æ›´æ–°ã™ã‚‹äºˆå®šã¯ãªã„ãŒã€Lexicalã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã‚’ä½¿ç”¨ã—ãŸ
       * ã‚ˆã£ã¦ã€readãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹
       */
      editorState.read(() => {
        // æœ€åˆã«ç”»é¢ã‚’é–‹ã„ãŸæ™‚ã¯è‡ªå‹•ã§ä¿å­˜ã™ã‚‹ã“ã¨ã‚’ã•ã‘ã‚‹ãŸã‚
        if (isFirst) {
          isFirst = false;
          return;
        }
        // ç™»éŒ²ã—ã¦ã„ã‚‹settimeouté–¢æ•°ã®å‡¦ç†ãŒã‚ã‚Œã°å‰Šé™¤ã™ã‚‹
        if (timer.current) {
          clearTimeout(timer.current);
        }
        // refã«settimeouté–¢æ•°ã‚’ä»£å…¥ã™ã‚‹
        timer.current = setTimeout(async () => {
          // Elasticsearchãªã©ã§æ¤œç´¢ã™ã‚‹ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ
          const editorStateTextString = createTextForSearch(editorState);
          // ã‚µãƒ¼ãƒãƒ¼å´ã§ã®å‡¦ç†ã€‚ä»Šå›ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨txtãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã‚“ã§ã„ã‚‹
          await storeContent(
            editorState.toJSON(),
            editorStateTextString,
            postId
          );
        }, 3000);
      });
    });
  }, [editor]);
  const createTextForSearch = (state: EditorState) => {
    // ç¾åœ¨ã®Editor Statesã‚’JSONæ–‡å­—åˆ—ã«ã™ã‚‹
    const stringifiedEditorState = JSON.stringify(state.toJSON());
    // æ–‡å­—åˆ—ã‹ã‚‰Editor Statesã‚’ä½œæˆ
    const parsedEditorState = editor.parseEditorState(stringifiedEditorState);
    // ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢ç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    return parsedEditorState.read(() => $getRoot().getTextContent());
  };
  return null;
};
export default AutoSavePlugin;
```

è‡ªå‹•ä¿å­˜æ©Ÿèƒ½è‡ªä½“ã¯ Lexical ã®å†…å®¹ã¯ã»ã¼ä½¿ç”¨ã—ã¦ã„ãªã„ã§ã™ã€‚
ãŸã ã€æ–‡å­—ãŒå…¥åŠ›ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°(â‰’Editor States ãŒæ›´æ–°ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°)ã§å‡¦ç†ãŒèµ°ã£ã¦æ¬²ã—ã„ãŸã‚ã€registerUpdateListener ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ç™»éŒ²ã—ã¦ã„ã¾ã™ã€‚
ã¾ãŸã€ä»Šå›ã¯ Editor States ã®å†…å®¹ã‚’æ›´æ–°ã—ãŸã„ã‚ã‘ã§ã¯ãªãã€Editor States ã®å†…å®¹ã‚’ä½¿ç”¨ã—ãŸã„ã ã‘ãªã®ã§ã€read ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
è‚å¿ƒã®è‡ªå‹•ä¿å­˜æ©Ÿèƒ½è‡ªä½“ã¯ä»¥ä¸‹ã®éƒ¨åˆ†ã§ã™ã€‚

```tsx
// ç™»éŒ²ã—ã¦ã„ã‚‹settimeouté–¢æ•°ã®å‡¦ç†ãŒã‚ã‚Œã°å‰Šé™¤ã™ã‚‹
if (timer.current) {
  clearTimeout(timer.current);
}
// refã«settimeouté–¢æ•°ã‚’ä»£å…¥ã™ã‚‹
timer.current = setTimeout(async () => {
  // Elasticsearchãªã©ã§æ¤œç´¢ã™ã‚‹ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ
  const editorStateTextString = createTextForSearch(editorState);
  // ã‚µãƒ¼ãƒãƒ¼å´ã§ã®å‡¦ç†ã€‚ä»Šå›ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨txtãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã‚“ã§ã„ã‚‹
  await storeContent(editorState.toJSON(), editorStateTextString, postId);
}, 3000);
```

registerUpdateListener ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–‡å­—ãŒå…¥åŠ›ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§éƒ½åº¦å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
ã¨ãªã‚‹ã¨ã€æ–‡å­—ã‚’æ•°æ–‡å­—å…¥åŠ›ã—ãŸã ã‘ã§åŒã˜å›æ•°ä¿å­˜å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚
ä¿å­˜ã™ã‚‹ã¨ã„ã†ç›®çš„ã¯é”æˆã—ã¦ã„ã‚‹ã‚‚ã®ã®ã€å…¥åŠ›ã®åº¦å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã®ã¯å°‘ã€…éå‰°ã§ã™ã€‚
ãã“ã§ã€setTimeout é–¢æ•°ã¨ useRef ã‚’ä½¿ã„å…¥åŠ›ãŒçµ‚ã‚ã£ã¦ã‹ã‚‰ 3 ç§’å¾Œã«ä¸€å›ä¿å­˜å‡¦ç†ãŒèµ°ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚
ä»•çµ„ã¿ã¨ã—ã¦ã¯ã€ç™»éŒ²ã—ãŸ setTimeout é–¢æ•°ã‚’ useRef ã«è¨­å®šã—ã€useRef ã«ç™»éŒ²ã—ãŸ setTimeout é–¢æ•°ãŒã‚ã£ãŸå ´åˆã€ç™»éŒ²è‡ªä½“ã‚’ç„¡ãã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€æœ€å¾Œã«å…¥åŠ›ã—ãŸ setTimeout é–¢æ•°ã—ã‹ç™»éŒ²ã•ã‚ŒãŸçŠ¶æ…‹ã«ãªã£ã¦ã„ãªã„ã®ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒä¸€å›ã§æ¸ˆã¿ã¾ã™ã€‚
å¾Œã¯ setTimeout é–¢æ•°å†…ã§ã‚µãƒ¼ãƒãƒ¼å´ã« JSON ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¸¡ã—ã€ãã‚Œã‚’å…ƒã«ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚“ã§ã„ã¾ã™ã€‚
ä»¥ä¸Šã§è‡ªå‹•ä¿å­˜ã®ä»•çµ„ã¿ãŒã§ãã¾ã™ã€‚
æ„å¤–ã¨ãƒ•ãƒ­ãƒ³ãƒˆå´ã§ã‚„ã‚‹ã“ã¨ã¯ãªã„ã®ã§ã€æ°—è»½ã«è¨­å®šã§ãã¾ã™ã€‚

## Lexical ã§é–‹ç™ºã—ãŸã„ã¨ãã®æ‰‹é †

Lexical ã¯ 2024 å¹´ 6 æœˆä¸­æ—¬æ™‚ç‚¹ã§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ 0.16.0 ã¨ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãªã£ã¦ãŠã‚Šã¾ã›ã‚“ã€‚
ã™ãªã‚ã¡ã€ã¾ã ã¾ã å¤‰æ›´ãŒå¤§ã„ã«ãªã•ã‚Œã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ã€‚
ãã®ãŸã‚ã‹ã€ãŠä¸–è¾ã«ã‚‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯å……å®Ÿã—ã¦ã„ã‚‹ã¨ã¯è¨€ãˆã¾ã›ã‚“ã€‚
åŸºæœ¬çš„ãªã“ã¨ã¯æ›¸ã„ã¦ã„ã¾ã™ãŒã€ç™ºå±•çš„ãªå†…å®¹ã«ã¤ã„ã¦ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒªãƒ³ã‚¯ã ã‘ã§ä¸­èº«ã®èª¬æ˜ãŒãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚
ãªã®ã§ã€Lexical ã‚’è§¦ã‚‹æ™‚ã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ãªãã€[ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰](https://playground.lexical.dev/)ã‚’è§¦ã£ã¦è¦‹ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚
ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§æ°—ã«ãªã‚‹æ©Ÿèƒ½ãŒã‚ã‚Œã°ã€GitHub ã®[lexical-playground](https://github.com/facebook/lexical/tree/main/packages/lexical-playground)å†…ã«è©²å½“ã—ãã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ¢ã™ã‚ˆã†ã«ã™ã‚Œã°ã€æ€ã£ã¦ã„ã‚‹ã‚ˆã‚Šã‚‚ã™ã‚“ãªã‚Šå®Ÿè£…ã§ãã¾ã™ã€‚
ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚ä¸ååˆ†ã§ã€æ—¥æœ¬èªã®è¨˜äº‹ã‚‚è±Šå¯Œã¨ã¯è¨€ãˆãªã„(ã¨ã¯ã„ãˆæ•°å°‘ãªã„æ—¥æœ¬èªã®è¨˜äº‹ã¯ç´ æ™´ã‚‰ã—ã„ã‚‚ã®ã°ã‹ã‚Šã§ã™ãŒ)ã®ã§ã€åŸºæœ¬çš„ã«ã¯ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¨ãã‚Œã«è©²å½“ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã§ã„ãé–‹ç™ºæ–¹æ³•ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ Lexical ã«ã¤ã„ã¦ã®æ¦‚è¦ã‚’ç°¡å˜ã«è¦‹ã¦ã„ãã€å®Ÿè£…ã®ä¸€éƒ¨ã‚’ç´¹ä»‹ã—ã¦ã„ãã¾ã—ãŸã€‚
ç‰¹ã«å®Ÿè£…éƒ¨åˆ†ã¯ã¨ã“ã‚ã©ã“ã‚çœç•¥ã—ã¦ã„ã‚‹éƒ¨åˆ†ãŒã‚ã£ãŸã‚Šã€å‰ææ¡ä»¶ãŒã¡ã‚ƒã‚“ã¨å…±æœ‰ã›ãšã«æ›¸ã„ã¦ã„ã‚‹éƒ¨åˆ†ã‚‚ã‚ã‚Šã¾ã™ã€‚
è¨˜äº‹ã¨ã—ã¦ã¯ã‚ã¾ã‚Šå®Œæˆåº¦ãŒé«˜ããªãæç¸®ã§ã™ãŒã€å°‘ã—ã§ã‚‚ Lexical ã®å¯èƒ½æ€§ã‚’æ„Ÿã˜ã¦ã‚‚ã‚‰ãˆãŸã‚‰å¹¸ã„ã§ã™ã€‚
ä¸€å¿œå®Ÿè£…ã—ã¦ã„ã‚‹ãƒªãƒã‚¸ãƒˆãƒªã‚‚å…±æœ‰ã—ã¦ãŠãã®ã§ã€æ°—ã«ãªã£ãŸã‚‰è¦—ã„ã¦ã‚‚ã‚‰ãˆã‚‹å¹¸ã„ã§ã™ã€‚
Lexical ã®å®Ÿè£…ã«ã¤ã„ã¦ã¯[nextjs-lexical/src/app/\_components/lexical](https://github.com/maronnjapan/document-blog/tree/main/nextjs-lexical/src/app/_components/lexical)ã«ã‚ã‚Šã¾ã™ã€‚
ã“ã“ã¾ã§èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚

# å‚è€ƒè³‡æ–™

[Meta ã®æ–°ã—ã„ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ Lexical ã‚’èª¿ã¹ã‚‹](https://zenn.dev/stin/articles/getting-started-with-lexical)
Lexical ã®æ—¥æœ¬èªè¨˜äº‹ã«ãŠã„ã¦æœ€ã‚‚æœ‰ç”¨ãªè¨˜äº‹ã®ä¸€ã¤ã€‚ãŸã ã§ã•ãˆæ—¥æœ¬èªã®æ–‡çŒ®ãŒå°‘ãªã„ä¸­ã§ã€ã“ã®ãƒ¬ãƒ™ãƒ«ã®è¨˜äº‹ãŒã‚ã‚‹ã®ã¯æŠ•ç¨¿è€…ã«æ„Ÿè¬ã—ã‹ãªã„ã§ã™ã€‚
[Meta ã®æ–°ã—ã„ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ Lexical ã‚’èª¿ã¹ã‚‹(å®Ÿè·µç·¨)](https://zenn.dev/stin/articles/lexical-rich-editor-trial)
ä¸Šã¨åŒã˜æŠ•ç¨¿è€…ã§ã€ç¥è¨˜äº‹ Part2 ã§ã™ã€‚ç§ãŒä½œã£ã¦ã„ã‚‹ã‚¨ãƒ‡ã‚£ã‚¿ã¯ã“ã®è¨˜äº‹ã®æ‹¡å¼µç‰ˆã«ãªã‚Šã¾ã™ã€‚
[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://lexical.dev/docs/intro)
